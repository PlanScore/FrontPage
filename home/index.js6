// this page's HTML template with the [hash] cache-buster
// and the only stylesheet
require('./index.scss');
require('./index.src.html');

// polyfills
//require('core-js/fn/array/includes');

// bundle some local/vendor libraries
//require('./js/leaflet-control-basemapbar.js');
//require('./js/leaflet-control-basemapbar.css');

//
// CONSTANTS
//

// the currently-visible state: boundary type + year, e.g. US House districts for 1984
// these are affected by window.selectXXX() family of functions which ultimately are all wrappers over loadDataForSelectedBoundaryAndYear()
const CURRENT_VIEW = {};

// the list of years to offer; used by the year picker so the user may choose dates
// note that not every state has data at all levels for every year
const PLAN_YEARS = [
    1972, 1974, 1976, 1978,
    1980, 1982, 1984, 1986, 1988, 
    1990, 1992, 1994, 1996, 1998,
    2000, 2002, 2004, 2006, 2008, 
    2010, 2012, 2014, 2016,
];

// the list of states, for mapping ABBR => NAME, for populating selectors, ...
const STATES = {
    'AL': 'Alabama',
    'AK': 'Alaska',
    'AZ': 'Arizona',
    'AR': 'Arkansas',
    'CA': 'California',
    'CO': 'Colorado',
    'CT': 'Connecticut',
    'DE': 'Delaware',
    'FL': 'Florida',
    'GA': 'Georgia',
    'HI': 'Hawaii',
    'ID': 'Idaho',
    'IL': 'Illinois',
    'IN': 'Indiana',
    'IA': 'Iowa',
    'KS': 'Kansas',
    'KY': 'Kentucky',
    'LA': 'Louisiana',
    'ME': 'Maine',
    'MD': 'Maryland',
    'MA': 'Massachusetts',
    'MI': 'Michigan',
    'MN': 'Minnesota',
    'MS': 'Mississippi',
    'MO': 'Missouri',
    'MT': 'Montana',
    'NE': 'Nebraska',
    'NV': 'Nevada',
    'NH': 'New Hampshire',
    'NJ': 'New Jersey',
    'NM': 'New Mexico',
    'NY': 'New York',
    'NC': 'North Carolina',
    'ND': 'North Dakota',
    'OH': 'Ohio',
    'OK': 'Oklahoma',
    'OR': 'Oregon',
    'PA': 'Pennsylvania',
    'RI': 'Rhode Island',
    'SC': 'South Carolina',
    'SD': 'South Dakota',
    'TN': 'Tennessee',
    'TX': 'Texas',
    'UT': 'Utah',
    'VT': 'Vermont',
    'VA': 'Virginia',
    'WA': 'Washington',
    'WV': 'West Virginia',
    'WI': 'Wisconsin',
    'WY': 'Wyoming',
};

// the bias numbers fitting into each colorful bucket
// used for the map choropleth, for the legend, other charts, ...
// the from/to/color are specifically for Highcharts, so don't rename them, but you could add more fields to suit other consumers
// the magical value -999999 represents No Data and will always be the first in this series
// see also renderMapLegend() which generates the legend
// see also loadDataForSelectedBoundaryAndYear() which assigns the color ramp for choropleth
const MAP_CHOROPLETH_BREAKS = [
    { from: -999999, to: -100, color: '#FFFFFF', title: 'No Data' },
    { from: -100, to: -0.20, color: '#C71C36', title: 'Most Biased Toward Republican' },
    { from: -0.20, to: -0.10, color: '#D95F72', title: 'More Biased Toward Republican' },
    { from: -0.10, to: -0.05, color: '#E8A2AD', title: 'Somewhat Biased Toward Republican' },
    { from: -0.05, to: -0.02, color: '#F5D7DC', title: 'Slightly Biased Toward Republican' },
    { from: -0.02, to: 0.02, color: '#F2E5FA', title: 'Balanced' },
    { from: 0.02, to: 0.05, color: '#D7E4F5', title: 'Slightly Biased Toward Democrat' },
    { from: 0.05, to: 0.10, color: '#99B7DE', title: 'Somewhat Biased Toward Democrat' },
    { from: 0.10, to: 0.20, color: '#4C7FC2', title: 'More Biased Toward Democrat' },
    { from: 0.20, to: 100, color: '#0049A8', title: 'Most Biased Toward Democrat' },
];

// when generating tooltips, a certain skew will be considered balanced and below statistical significance
// this would correspond to the Balanced choropleth break defined above (+X to -X is still balanced)
const BIAS_BALANCED_THRESHOLD = 0.02;

//
// PAGE STARTUP / INIT FUNCTIONS
//

$(document).ready(function () {
    initYearPickers();
    initStatePicker();
    initBoundaryPicker();
    initLoadStartingConditions();  // this will implicitly call loadDataForSelectedBoundaryAndYear() after setup, loading the map

    $(window).on('resize', handleResize);
    handleResize();
});

window.initYearPickers = () => {
    // there are 2 year pickers: mobile and full-size
    // mobile is a simple SELECT element and changing it selects a year
    // desktop is a fancy series of HTML/CSS dots which can be clicked to select a year
    // both of these connect to selectYear()

    const $picker_small = $('#yearpicker-small');
    PLAN_YEARS.slice().reverse().forEach((year) => {
        $('<option></option>').text(year).prop('value', year).appendTo($picker_small);
    });
    $picker_small.change(function () {
        const year = $(this).val();
        selectYear(year);
    });

    const $picker_big = $('#yearpicker-big');
    PLAN_YEARS.forEach((year) => {
        // each button has some utility classes so we can call out certain landmark years
        // see also handleResize() which adjusts the full-width spacing behavior
        const $button = $('<div><a></a></div>').attr('data-year', year).prop('title', `Show partisan bias analysis for ${year}`).appendTo($picker_big);
        if (year % 10 === 0) $button.addClass('decade');
        if (year % 4 === 0) $button.addClass('presidential');

        if (year % 10 === 0) {
            $('<span></span>').text(year).appendTo($button);
        }
    });
    $picker_big.on('click', 'div', function () {
        const year = $(this).attr('data-year');
        selectYear(year);
    });
};

window.initStatePicker = () => {
    // state picker is the UI for selectState() to show a popup for the given state
    const $picker = $('#statepicker');
    $('<option></option>').text('(select state)').prop('value', '').appendTo($picker);
    for (const [stateabbr, statename] of Object.entries(STATES)) {
        $('<option></option>').text(statename).prop('value', stateabbr).appendTo($picker);
    }

    $picker.change(function () {
        const stateabbr = $(this).val();
        selectState(stateabbr);
    });

    // when the modal closes, also explicitly select no state so as to reset the UI
    $('#stateinfo-modal').on('hidden.bs.modal', function (e) {
        selectState(null);
    });
};

window.initBoundaryPicker = () => {
    $('#boundarypicker div[data-boundary]').click(function () {
        const boundarytype = $(this).attr('data-boundary');
        selectBoundaryType(boundarytype);
    });
};

window.initLoadStartingConditions = () => {
    // analyze the #year-polytype hash to see what year + type we should load
    // provide some defaults
    let year = PLAN_YEARS[PLAN_YEARS.length - 1];
    let type = 'ushouse';

    const year_and_type = /^#!(\d\d\d\d)\-(\w+)$/.exec(window.location.hash);
    if (year_and_type) {
        year = year_and_type[1];
        type = year_and_type[2];
    }

    // ready, set, go
    selectYear(year);
    selectBoundaryType(type);
};

window.handleResize = () => {
    // various things that don't gracefully handle being resized, so we need to help them out

    // the desktop "bead string" yearpicker; stretch the DIVs to fill the width
    const $picker_buttons = $('#yearpicker-big').find('div');
    const width = `${100 / $picker_buttons.length}%`;
    $picker_buttons.css({ width });

};


//
// RUNTIME FUNCTIONS FOR CHANGING YEAR + DISTRICT TYPE + STATE INFO
// loadDataForSelectedBoundaryAndYear() is the real worker here; the others are basically convenience functions
//

window.loadDataForSelectedBoundaryAndYear = () => {
    if (! CURRENT_VIEW.year || ! CURRENT_VIEW.boundtype) return;  // need both; during startup one will be blank, so avoid an error

    // if there's a map already, destroy it
    const existing_map = $('#map').data('mapchart');
    if (existing_map) {
        existing_map.destroy();
        $('#map').data('mapchart', null);
    }

    // initialize the bias score statistics to -999999 No Data all around
    // expected data structure: list of states and their bias ratings
    const chartdata = [];
    for (const [stateabbr, statename] of Object.entries(STATES)) {
        chartdata.push({
            abbr: stateabbr,
            name: statename,
            value: -999999,
        });
    }

    // fetch the CSV file and then use the callbacks to update the map
    const url = `../data/bias_${CURRENT_VIEW.boundtype}.csv`;
    Papa.parse(url, {
        download: true,
        header: true,
        complete: function (results) {
            // filter by the year (geography is implicit by which CSV was fetched)
            // and for each row assign the bias score to the state's row in the above
            // this is loop-within-loop as we match arrays to arrays, but P=50 and Q=20ish so it's affordable
            results = results.data.forEach(function (row) {
                if (row.year != CURRENT_VIEW.year) return;  // wrong year; next
                chartdata.filter((datarow) => { return datarow.abbr == row.state; })[0].value = parseFloat(row.eg_adj_avg);
            });
            renderMapWithNewData(chartdata);
            renderMapLegend();
            updateStateListingSwatches(chartdata);
        },
    });

    function renderMapWithNewData(data) {
        // attach this raw data into the chart DIV so we can access it later
        // see also selectState() which needs to access the compiled data
        $('#map').data('biasdata', data);

        // Highcharts trick: load up the us-small data which includes breakout boxes for the small New England States (issue 78)
        // preprocess it to add the state's ABBR as the label for the boxes
        const polygons = Highcharts.geojson(Highcharts.maps['countries/us/custom/us-small']);
        $.each(polygons, function () {
            var path = this.path, copy = { path: path };

            if (path[1] === 9727) {
                Highcharts.seriesTypes.map.prototype.getBox.call({}, [copy]);
                this.middleX = ((path[1] + path[4]) / 2 - copy._minX) / (copy._maxX - copy._minX); // eslint-disable-line no-underscore-dangle
                this.middleY = ((path[2] + path[7]) / 2 - copy._minY) / (copy._maxY - copy._minY); // eslint-disable-line no-underscore-dangle
            }
        });

        // render the map chart
        const newmapchart = Highcharts.mapChart('map', {
            chart: {
                borderWidth: 0,
            },
            title: {
                text: '',  // no big title
            },
            legend: {
                enabled: false,  // we have a custom-crafted label
            },
            colorAxis: {
                dataClasses: MAP_CHOROPLETH_BREAKS,
            },
            tooltip: {  // the tooltips are kept minimal, as most info is in a popup when clicked and mobile folks can't use tooltips effectively
                formatter: function() {
                    return this.key;  // the state name
                },
                positioner: function (labelWidth, labelHeight, point) {  // center the tooltip on the state, instead of using the mouse; issue 78
                    const width = this.chart.chartWidth;
                    const height = this.chart.chartHeight;

                    const x = (width / 2) - 30;  //could use (labelWidth/2) but then the box "jumps around"
                    const y = height - labelHeight - 5;
                    return { x, y };
                },
            },
            series: [{
                // use the Highcharts-provided US states, joining on their "postal-code" to our "abbr"
                data: data,
                mapData: polygons,
                joinBy: ['postal-code', 'abbr'],
                // labels make small states easier to see, cursor makes it obvious to click
                cursor: 'pointer',
                dataLabels: {
                    enabled: true,
                    formatter: function () {
                        return this.point.abbr;
                    },
                    style: {
                        fontSize: '9px',
                    }
                },
                // click events: call the popup maker
                events: {
                    click: function (e) {
                        selectState(e.point.abbr);
                    }
                },
            }]
        });

        // stow that reference so we can destroy it on next data load
        $('#map').data('mapchart', newmapchart);
    }

    function renderMapLegend() {
        const $legend = $('<div class="legend"></div>').appendTo('#map');

        const legend_slices = [ ...MAP_CHOROPLETH_BREAKS.slice(1), MAP_CHOROPLETH_BREAKS[0] ];

        $('<h1>Most biased plan in our data</h1>').appendTo($legend);
        $('<h2>(based on efficiency gap)</h2>').appendTo($legend);

        legend_slices.forEach((legendentry, i, allslices) => {
            const $slice = $('<div class="slice"></div>').css({ 'background-color':legendentry.color }).prop('title', legendentry.title).appendTo($legend);
            if (i === 0) {  // first real slice = R
                $slice.append('<span>R</span>');
            }
            else if (i === allslices.length - 2) {  // last real slice = D
                $slice.append('<span>D</span>');
            }
        });

        $('<h5>No Data</h5>').appendTo($legend);  // last slice will be the No Data, here are the words to go with it
    }

    function updateStateListingSwatches(data) {
        const $swatches = $('.states-listing span.swatch');
        $swatches.each(function () {
            // find this swatch's state name, and fetch that state info from the raw data
            const state_name = $(this).closest('a').text().trim();
            const state_info = data.filter((stateinfo) => { return stateinfo.name === state_name; }).slice(0, 1)[0];

            // figure out the state's color based on the bias rating
            const bias_color = MAP_CHOROPLETH_BREAKS.filter((rampentry) => {
                return state_info.value >= rampentry.from && state_info.value <= rampentry.to;
            })[0];

            // apply it
            $(this).css({ 'background-color': bias_color.color }).prop('title', bias_color.title);
        });
    }

    // update URL params to show the current search
    // see also initLoadStartingConditions() which will load such a state
    const hash = `#!${CURRENT_VIEW.year}-${CURRENT_VIEW.boundtype}`;
    window.location.replace(hash);
};

window.selectYear = (year) => {
    // UI update: highlight this button
    $('#yearpicker-big div').removeClass('active').filter(`[data-year="${year}"]`).addClass('active');

    // save to the state and refresh the map + data
    CURRENT_VIEW.year = year;
    loadDataForSelectedBoundaryAndYear();
};

window.selectBoundaryType = (boundtype) => {
    // UI update: highlight this button
    $('#boundarypicker div[data-boundary]').removeClass('active').filter(`[data-boundary="${boundtype}"]`).addClass('active');

    // save to the state and refresh the map + data
    CURRENT_VIEW.boundtype = boundtype;
    loadDataForSelectedBoundaryAndYear();
};

window.selectState = (stateabbr) => {
    // note that blank is an acceptable option to select no state at all
    if (! stateabbr) stateabbr = '';

    // UI update: set the selector
    $('#statepicker').val(stateabbr);

    // show/hide the popup
    if (stateabbr) {
        // fetch the info from the map, and attach some attributes for the popup
        // tip: shallow copy via slice() so as not to mutate the existing one
        const biasinfo = $('#map').data('biasdata').filter((statedata) => { return statedata.abbr === stateabbr; }).slice(0, 1)[0];

        // add to the info, an analysis
        if (biasinfo.value === -999999) {
            biasinfo.analysis = 'No data available.';
        }
        else if (Math.abs(biasinfo.value) <= BIAS_BALANCED_THRESHOLD) {
            biasinfo.analysis = `This plan shows no statistically significant skew toward either party.`;
        }
        else if (biasinfo.value < 0) {  // R bias
            biasinfo.analysis = `This plan is more biased than <b>${50 + Math.round(Math.abs(biasinfo.value) * 100)}%</b> plans analyzed.<br/>This plan is biased in favor of <b>Republican</b> voters.`;
        }
        else {  // must be D bias
            biasinfo.analysis = `This plan is more biased than <b>${50 + Math.round(Math.abs(biasinfo.value) * 100)}%</b> of plans analyzed.<br/>This plan is biased in favor of <b>Democrat</b> voters.`;
        }

        // the URL for more info: the state name, mangled for URLs e.g. south_carolina
        const moreinfourl = `../${biasinfo.name.toLowerCase().replace(/\W/g, '_')}/`;

        // open the modal and do the string replacements
        const $modal = $('#stateinfo-modal').modal('show');
        $modal.find('span[data-field="statename"]').html(biasinfo.name);
        $modal.find('span[data-field="analysis"]').html(biasinfo.analysis);
        $modal.find('.modal-footer a').prop('href', moreinfourl);
    }
    else {
        // nothing to do, except I guess close the modal if it happens to be open
        $('#stateinfo-modal').modal('hide');
    }
};

//
// OTHER RUNTIME FUNCTIONS
//
