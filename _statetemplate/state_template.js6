// this page's HTML template with the [hash] cache-buster
// and the only stylesheet
require('./index.scss');
require('./index.src.html');

// shared constants between pages: the list of years, the red-blue color gradient, ...
import { PLAN_YEARS } from "./../planscore_common";
import { COLOR_GRADIENT } from "./../planscore_common";
import { STATE_NAME_TO_CODE } from "./../planscore_common";

// bundle polyfills and local/vendor libraries specific to this page
//require('core-js/fn/array/includes');
//require('./js/leaflet-control-basemapbar.js');
//require('./js/leaflet-control-basemapbar.css');


//
// CONSTANTS
//

// the currently-visible state: boundary type + year, e.g. US House districts for 1984
// these are affected by window.selectXXX() family of functions which ultimately are all wrappers over loadDataForSelectedBoundaryAndYear()
const CURRENT_VIEW = {};


//
// PAGE STARTUP / INIT FUNCTIONS
//

$(document).ready(function () {
    // see also SELECTED_STATE declaration hardcoded into HTML template

    initYearPickers();
    initBoundaryPicker();
    initLoadStartingConditions();  // this will implicitly call loadDataForSelectedBoundaryAndYear() after setup, loading the map

    $(window).on('resize', handleResize);
    handleResize();
});

window.handleResize = () => {
    // various things that don't gracefully handle being resized, so we need to help them out
};

window.initYearPickers = () => {
    // a simple SELECT to choose a year, and trigger selectYear()

    const $picker_small = $('#yearpicker-small');
    PLAN_YEARS.slice().reverse().forEach((year) => {
        $('<option></option>').text(year).prop('value', year).appendTo($picker_small);
    });
    $picker_small.change(function () {
        const year = $(this).val();
        selectYear(year);
    });
};

window.initBoundaryPicker = () => {
    $('#boundarypicker div[data-boundary]').click(function () {
        const boundarytype = $(this).attr('data-boundary');
        selectBoundaryType(boundarytype);
    });
};

window.initLoadStartingConditions = () => {
    // analyze the #year-polytype hash to see what year + type we should load
    // provide some defaults
    let year = PLAN_YEARS[PLAN_YEARS.length - 1];
    let type = 'ushouse';

    const year_and_type = /^#!(\d\d\d\d)\-(\w+)$/.exec(window.location.hash);
    if (year_and_type) {
        year = year_and_type[1];
        type = year_and_type[2];
    }

    // ready, set, go
    selectYear(year);
    selectBoundaryType(type);
};


//
// RUNTIME FUNCTIONS FOR CHANGING YEAR + DISTRICT TYPE
// loadDataForSelectedBoundaryAndYear() is the real worker here; the others are basically convenience functions
//

window.loadDataForSelectedBoundaryAndYear = () => {
    if (! CURRENT_VIEW.year || ! CURRENT_VIEW.boundtype) return;  // need both; during startup one will be blank, so avoid an error

    // fetch the CSV file and then use the callbacks to update the map
    const url = `../data/bias_${CURRENT_VIEW.boundtype}.csv`;
    Papa.parse(url, {
        download: true,
        header: true,
        complete: function (results) {
            // district type was implicitly "filtered" by which CSV was fetched; now filter by this state
            const alldataforthisstate = results.data.filter((row) => {
                return row.state == STATE_NAME_TO_CODE[SELECTED_STATE];
            });
            updateStatsFromCsvContent(alldataforthisstate);
        },
    });

    // update URL params to show the current search
    // see also initLoadStartingConditions() which will load such a state
    const hash = `#!${CURRENT_VIEW.year}-${CURRENT_VIEW.boundtype}`;
    window.location.replace(hash);
};

window.selectYear = (year) => {
    // UI update: highlight this button
    $('#yearpicker-small').val(year);

    // save to the state and refresh the map + data
    CURRENT_VIEW.year = year;
    loadDataForSelectedBoundaryAndYear();
};

window.selectBoundaryType = (boundtype) => {
    // UI update: highlight this button
    $('#boundarypicker div').removeClass('active').filter(`[data-boundary="${boundtype}"]`).addClass('active');

    // save to the state and refresh the map + data
    CURRENT_VIEW.boundtype = boundtype;
    loadDataForSelectedBoundaryAndYear();
};

window.updateStatsFromCsvContent = (allcsvdata) => {
    // general info not related to any specific year
    // how many distinct plans and years are listed for this district type?
    const distinct_years = {};
    const distinct_plans = {};
    allcsvdata.forEach((row) => {
        distinct_years[row.year] = true;
        distinct_plans[row.plan] = true;
    });
    $('span[data-metric="electioncount"]').text(Object.keys(distinct_years).length.toLocaleString());
    $('span[data-metric="plancount"]').text(Object.keys(distinct_plans).length.toLocaleString());

    // handle a condition of no data at all for this whole district type, for any year
    if (allcsvdata.length) {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="true"]').show();
    }
    else {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="false"]').show();
        return;  // nothing else we can do until they select a district type with data
    }

    // filter to the data for the selected year, to get the specific planin effect that year
    // then show the "no data for this year" content if we have data for this district, but not this year
    const thisplan = allcsvdata.filter((row) => { return row.year == CURRENT_VIEW.year; })[0];
    if (thisplan) {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-thisyear="true"]').show();
    }
    else {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-thisyear="false"]').show();
        return;  // nothing else we can do until they select a year which has data
    }

    // cast a few fields as floats
    [ 'eg_adj_avg', 'bias_avg', 'mmd_avg'
    ].forEach((fieldname) => {
            thisplan[fieldname] = parseFloat(thisplan[fieldname]);
        });

    // for the selected plan
    // the 3 plan-bias metrics: do any of them show a bias toward D or R?
    // compose a sentence summarizing the biases
    // AND ALSO tag the biasicon icons in the metrics' tabs

/*
eg_adj_avg
bias_avg
mmd_avg
*/

//gda
console.log(thisplan);

};
