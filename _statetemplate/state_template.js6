// this page's HTML template with the [hash] cache-buster
// and the only stylesheet
require('./index.scss');
require('./index.src.html');

// shared constants between pages: the list of years, the red-blue color gradient, ...
import { PLAN_YEARS } from "./../planscore_common";
import { STATE_NAME_TO_CODE } from "./../planscore_common";
import { CONUS_BOUNDS } from "./../planscore_common";
import { STATE_BOUNDING_BOXES } from "./../planscore_common";
import { lookupBiasColor, lookupBiasFavorParty } from "./../planscore_common";

// bundle polyfills and local/vendor libraries specific to this page
require('core-js/fn/object/values');
require('./../jslibs/leaflet-control-zoombar.js');
require('./../jslibs/leaflet-control-zoombar.css');
require('./../jslibs/leaflet-polygon.fillPattern.js');


//
// CONSTANTS
//

// the currently-visible state: boundary type + year, e.g. US House districts for 1984
// these are affected by window.selectXXX() family of functions which ultimately are all wrappers over loadDataForSelectedBoundaryAndYear()
const CURRENT_VIEW = {
    // year: '2000',  // four-digit year (string)
    // boundtype: 'ushouse',  // short polygon name: ushouse statehouse statesenate
    // planorelection: 'election',  // show 'election' or 'plan' statistics on right-hand side
};

// Efficiency Gap wasted vote chart; colors
const WASTEDVOTE_CHART_WASTED_D = '#0049A8';
const WASTEDVOTE_CHART_WASTED_R = '#C71C36';
const WASTEDVOTE_CHART_USEFUL_D = '#99b7dc';
const WASTEDVOTE_CHART_USEFUL_R = '#e8a4ad';

// for the bellcurve charts, the data spread (min + max absolute values)
// so we can interpolate a value and position a marker line indicating a value
// see drawBiasBellChart()
const BELLCURVE_SPREAD = {
    eg: 0.22,
    mm: 0.11,
    pb: 0.30,
};

// what fields to use for Election Mode and Plan Mode
// each record contains bias-related statistics for both that specific election-year and the average of all years the plan was implemented
// e.g. mmd and mmd_avg, eg_percentrank and eg_avg_percentrank
// the various sub-systems from updateStatsFromCsvContent() will need to load "the bias field" based on whether CURRENT_VIEW.planorelection indicates that we want a Election Year or a Plan Overview
// example:   fetch the bias score from either 'the election field' or 'the plan field' as necessary
//            const relevantbiasfield = ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias;
//            const bias_score        = thisyeardata[relevantbiasfield];
// not all fields are listed here, just the ones which vary between election view and plan view
const ELECTION_PLAN_RECORD_FIELDS = {
    'election': {
        'eg': 'eg_adj',
        'egrank': 'eg_percentrank',
        'bias': 'bias',
        'biasrank': 'bias_percentrank',
        'mm': 'mmd',
        'mmrank': 'mmd_percentrank',
        'wasted_dem': 'wasted_dem',
        'wasted_rep': 'wasted_rep',
        'votes_dem': 'votes_dem',
        'votes_rep': 'votes_rep',
        'votes_both': 'votes_twop',
        'seats': 'seats',
        'seats_dem': 'seats_dem',
        'seats_rep': 'seats_r',
    },
    'plan': {
        'eg': 'eg_adj_avg',
        'egrank': 'eg_avg_percentrank',
        'bias': 'bias_avg',
        'biasrank': 'bias_avg_percentrank',
        'mm': 'mmd_avg',
        'mmrank': 'mmd_avg_percentrank',
        'wasted_rep': 'wasted_rep_plan',
        'wasted_dem': 'wasted_dem_plan',
        'votes_dem': 'votes_dem_plan',
        'votes_rep': 'votes_rep_plan',
        'votes_both': 'votes_twop_plan',
        'seats': 'seats_plan',
        'seats_dem': 'seats_dem_plan',
        'seats_rep': 'seats_r_plan',
    },
};

// the bounding box of this state
const STATE_BBOX = STATE_BOUNDING_BOXES[STATE_NAME_TO_CODE[SELECTED_STATE]];

// for the map of election winnders & plan winners, the styles
const MAP_DISTRICT_STYLE_DEFAULT = {
    stroke: true, color: '#cccccc', weight: 1,
    fill: "url(/images/mapfill_nodata.png)", fillColor: 'transparent', fillOpacity: 0.6,  // crosshatch image fill, thanks to leaflet-polygon.fillPattern.js
    bubblingMouseEvents: false,
    clickable: false,
};
const MAP_DISTRICT_STYLE_DEMOCRAT = {
    stroke: true, color: '#cccccc', weight: 1,
    fill: true, fillColor: '#0049A8', fillOpacity: 0.6,
    bubblingMouseEvents: false,
    clickable: false,
};
const MAP_DISTRICT_STYLE_REPUBLICAN = {
    stroke: true, color: '#cccccc', weight: 1,
    fill: true, fillColor: '#C71C36', fillOpacity: 0.6,
    bubblingMouseEvents: false,
    clickable: false,
};


//
// PAGE STARTUP / INIT FUNCTIONS
//

$(document).ready(function () {
    // see also SELECTED_STATE declaration hardcoded into HTML template

    initYearPickers();
    initBoundaryPicker();
    initMap();
    initMetricTabTracking();
    initLoadStartingConditions();  // this will implicitly call loadDataForSelectedBoundaryAndYear() after setup, loading the map

    $(window).on('resize', handleResize);
    handleResize();
});

window.handleResize = () => {
    // various things that don't gracefully handle being resized, so we need to help them out
};

window.initMap = () => {
    // the map of the state, in its initial state with no data
    // basemap + labels with some hacks on the pane-and-zindex of the labels
    // simple zoom+home control
    // see also updateMapForCurrentSelection() which updates the map to the given election/plan/year

    window.MAP = L.map('map', {
        minZoom: 4,
        maxZoom: 11,
        zoomControl: false,
        scrollWheelZoom: false,
    }).fitBounds(STATE_BBOX);

    L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_nolabels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
        subdomains: 'abcd',
    }).addTo(MAP);
    L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-labels/{z}/{x}/{y}{r}.png', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.',
        subdomains: 'abcd',
        pane: 'markerPane',
    }).addTo(MAP);

    new L.Control.ZoomBar({
        position: 'topright',
        homeBounds: STATE_BBOX,
    }).addTo(MAP);


    // more prep work: create L.TopoJSON which parses both GeoJSON and TopoJSON
    L.TopoJSON = L.GeoJSON.extend({
        addData: function(jsonData) {
            if (jsonData.type === "Topology") {
                for (var key in jsonData.objects) {
                    const geojson = topojson.feature(jsonData, jsonData.objects[key]);
                    L.GeoJSON.prototype.addData.call(this, geojson);
                }
            }    
            else {
                L.GeoJSON.prototype.addData.call(this, jsonData);
            }
        }
    });
};

window.initYearPickers = () => {
    // mobile
    // two separate UIs for cycling through prev/next election year or district plan
    // only one is visible and that's based on whether our URL (or defaults) indicate that we want to see a year/plan
    // see initLoadStartingConditions() for that startup logic to show only one
    // see selectElectionOrPlan() which does the real work when prev/next are performed
    const $plan_picker = $('#yearpicker-small > div[data-picker="plan"]');
    const $year_picker = $('#yearpicker-small > div[data-picker="election"]');
    const $year_listing = $year_picker.find('div.readout');
    const $plan_listing = $plan_picker.find('div.readout');

    PLAN_YEARS.forEach((year) => {
        $(`<span data-year="${year}">${year} Election</span>`).appendTo($year_listing).hide();
    });

    $year_picker.on('click', 'i[data-role="next"]', function () {
        const $targetbutton = $year_listing.find('span:visible').next('span');
        const year = $targetbutton.attr('data-year');
        selectElectionOrPlan(year, 'election');
    });
    $year_picker.on('click', 'i[data-role="prev"]', function () {
        const $targetbutton = $year_listing.find('span:visible').prev('span');
        const year = $targetbutton.attr('data-year');
        selectElectionOrPlan(year, 'election');
    });

    // there won't be any plans listed here at startup; see redrawYearPicker() since the list of plans depends on district type
    $plan_picker.on('click', 'i[data-role="next"]', function () {
        const $targetbutton = $plan_listing.find('span:visible').next('span');
        const year = $targetbutton.attr('data-year');
        selectElectionOrPlan(year, 'plan');
    });
    $plan_picker.on('click', 'i[data-role="prev"]', function () {
        const $targetbutton = $plan_listing.find('span:visible').prev('span');
        const year = $targetbutton.attr('data-year');
        selectElectionOrPlan(year, 'plan');
    });

    // desktop
    // the list of "year beads" running down the side, which is two columns for election years (right) and district plans (left)
    // see also redrawYearPicker() which assigns the data-plan="" attribute to plans, and shows/hides election years
    // both bases on the actual data present
    const $picker_big   = $('#yearpicker-big');
    const $plansdiv     = $('<div class="plans col-xs-5"></div>').appendTo($picker_big);
    const $electionsdiv = $('<div class="elections col-xs-7"></div>').appendTo($picker_big);
    
    $('<span>Election<br>Years</span>').appendTo($electionsdiv);
    $('<span>Enacted<br>Plans</span>').appendTo($plansdiv);

    PLAN_YEARS.slice().reverse().forEach((year) => {
        $(`<a data-year="${year}" title="Show details for the ${year} election year"><span></span> ${year}</a>`).appendTo($electionsdiv);
        $(`<a data-year="${year}" title="Show details for this districting plan"><span></span></a>`).appendTo($plansdiv);  // will be tagged with data-plan attribute when we have data
    });

    $electionsdiv.on('click', 'a', function () {
        const year = $(this).attr('data-year');
        // issue 94: for the time being, years also go to Plans not election-year details
        //selectElectionOrPlan(year, 'election');
        selectElectionOrPlan(year, 'plan');
    });

    $plansdiv.on('click', 'a', function () {
        const year = $(this).attr('data-year');
        selectElectionOrPlan(year, 'plan');
    });
};

window.initBoundaryPicker = () => {
    $('#boundarypicker div[data-boundary]').click(function () {
        const boundarytype = $(this).attr('data-boundary');
        selectBoundaryType(boundarytype);
    });
};

window.initMetricTabTracking = () => {
    // when they switch metrics tabs, log a Google Analytics event
    $('#tabs-metrics a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
        const whichtab = $(e.target).prop('href').replace(/.+#tab-/, '');  // the suffix is the metric name, e.g. #tab-efficiencygap
        logMetricToggleToGoogleAnalytics(whichtab);
    });
};

window.initLoadStartingConditions = () => {
    // analyze the #year-polytype hash to see what year + type we should load
    // see alsoupdateUrlHash() which generates this hash

    let year = PLAN_YEARS[PLAN_YEARS.length - 1];
    let what = 'plan';
    let type = 'ushouse';

    const year_and_type = /^#!(\d\d\d\d)\-(\w+)\-(\w+)$/.exec(window.location.hash);
    if (year_and_type) {
        year = year_and_type[1];  // the year
        what = year_and_type[2];  // election or plan
        type = year_and_type[3];  // district type
    }

    // toggle which yeapricker-small is displayed
    // per issue 129 only one of these is visible and that depends on whether the page loads with a plan/election
    $('#yearpicker-small > div').hide().filter(`[data-picker="${what}"]`).show();

    // ready, set, go
    selectElectionOrPlan(year, what);
    selectBoundaryType(type);
};


//
// RUNTIME FUNCTIONS FOR CHANGING YEAR + DISTRICT TYPE
// loadDataForSelectedBoundaryAndYear() is the real worker here; the others are basically convenience functions
//

window.loadDataForSelectedBoundaryAndYear = () => {
    if (! CURRENT_VIEW.year || ! CURRENT_VIEW.boundtype) return;  // need both; during startup one will be blank, so avoid an error

    // fetch the CSV file and then use the callbacks to update the map
    const url = `/data/bias_${CURRENT_VIEW.boundtype}.csv`;
    Papa.parse(url, {
        download: true,
        header: true,
        complete: function (results) {
            // district type was implicitly "filtered" by which CSV was fetched; now filter by this state
            const alldataforthisstate = results.data.filter((row) => {
                return row.state == STATE_NAME_TO_CODE[SELECTED_STATE];
            });

            // data fixes
            results.data.forEach((row) => {
                // cast fields to integer
                [
                    'eg_adj', 'eg_adj_avg', 'eg_avg_percentrank', 'eg_percentrank',
                    'bias', 'bias_avg','bias_avg_percentrank', 'bias_percentrank',
                    'mmd', 'mmd_avg', 'mmd_avg_percentrank', 'mmd_percentrank',
                ].forEach((fieldname) => { row[fieldname] = parseFloat(row[fieldname]); });

                // cast fields to integer
                [
                    'votes_twop_plan', 'votes_twop', 'votes_dem_plan',  'votes_dem',
                    'wasted_dem_plan', 'wasted_dem',
                    'wasted_rep_plan', 'wasted_rep',
                    'seats_plan',  'seats',
                    'seats_dem_plan',  'seats_dem',
                    'seats_r_plan', 'seats_r',
                ].forEach((fieldname) => { row[fieldname] = parseInt(row[fieldname]); });

                // create the votes_rep and votes_rep_plan
                row.votes_rep_plan = row.votes_twop_plan - row.votes_dem_plan;
                row.votes_rep      = row.votes_twop - row.votes_dem;
            });

            // data fixes: go through the CSV and add a plan_minyear and plan_maxyear attribute
            // this is the min and max year in which that year's "plan" was in effect
            {
                // pass 1: 
                let plans_analyzed = {};
                results.data.forEach((row) => {
                    if (! plans_analyzed[row.plan]) {
                        // not seen this year before; assume this is the first and last year of this newly-found plan
                        plans_analyzed[row.plan] = { minyear: row.year, maxyear: row.year };
                    }
                    else {
                        // we've seen this plan, update the min and max if appropriate
                        if (row.year < plans_analyzed[row.plan].minyear) plans_analyzed[row.plan].minyear = row.year;
                        if (row.year > plans_analyzed[row.plan].maxyear) plans_analyzed[row.plan].maxyear = row.year;
                    }
                });

                // pass 2: go through the rows and update from the plans_analyzed
                results.data.forEach((row) => {
                    row.plan_minyear = plans_analyzed[row.plan].minyear;
                    row.plan_maxyear = plans_analyzed[row.plan].maxyear;
                });
            }

            // ready, set, go!
            updateStatsFromCsvContent(alldataforthisstate);

            // log the GA request
            logRequestToGoogleAnalytics();
        },
        error: function () {
            // an error, meaning bad network or missing CSV
            // treat this the same as receiving 0 rows, so the UI states that it has no data
            updateStatsFromCsvContent([]);
        },
    });

    // update URL params to show the current search
    updateUrlHash();
};

window.logRequestToGoogleAnalytics = () => {
    if (! gtag) return;  // no Google Tag Manager = don't bother; this should be declared along with GTM

    gtag('event', 'statedetails', {
        name: STATE_NAME_TO_CODE[SELECTED_STATE],
        value: CURRENT_VIEW.year,
        event_category: CURRENT_VIEW.planorelection,
        event_label : CURRENT_VIEW.boundtype,
    });
};

window.updateUrlHash = () => {
    // update URL params to show the current search
    // see also initLoadStartingConditions() which will load such a state
    const hash = `#!${CURRENT_VIEW.year}-${CURRENT_VIEW.planorelection}-${CURRENT_VIEW.boundtype}`;
    window.location.replace(hash);
};

window.selectElectionOrPlan = (year, planorelection) => {
    // UI update: highlight this button or select this option
    $('#yearpicker-small').val(`${year}-${planorelection}`);

    // go through the election years (right side) and plan spans (left side)
    // and tag them to indicate what we're highlighting: this election year, or this districting plan
    const $elinks = $('#yearpicker-big div.elections a').removeClass('active');
    //const $plinks = $('#yearpicker-big div.plans a').removeClass('active');
    if (planorelection == 'election') {
        $elinks.filter(`[data-year="${year}"]`).addClass('active');
    }
    else {
        // the plans timeline is redrawn by loadDataForSelectedBoundaryAndYear() since it depends on what was selected
    }

    // save to the state and refresh the map + data
    CURRENT_VIEW.year = year;
    CURRENT_VIEW.planorelection = planorelection;
    loadDataForSelectedBoundaryAndYear();
};

window.selectBoundaryType = (boundtype) => {
    // UI update: highlight this button
    $('#boundarypicker div').removeClass('active').filter(`[data-boundary="${boundtype}"]`).addClass('active');

    // save to the state and refresh the map + data
    CURRENT_VIEW.boundtype = boundtype;
    loadDataForSelectedBoundaryAndYear();
};

window.updateStatsFromCsvContent = (allcsvdata) => {
    // handle a condition of no data at all for this whole district type, for any year
    if (allcsvdata.length) {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="true"]').show();
    }
    else {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="false"]').show();
        return;  // nothing else we can do until they select a district type with data
    }

    // okay so we have SOME data for this state + district type
    // how many distinct plans and years are listed for this district type?
    const distinct_years = {};
    const distinct_plans = {};
    allcsvdata.forEach((row) => {
        distinct_years[row.year] = true;
        distinct_plans[row.plan] = true;
    });
    $('span[data-metric="electioncount"]').text(Object.keys(distinct_years).length.toLocaleString());
    $('span[data-metric="plancount"]').text(Object.keys(distinct_plans).length.toLocaleString());

    // okay so we have SOME data for this state + district type
    // redraw the large yearpicker, indicating years in which a new plan was implemented
    redrawYearPicker(allcsvdata);

    // final check: do we have data for this district for the selected year?
    const thisyeardata = allcsvdata.filter((row) => { return row.year == CURRENT_VIEW.year; })[0];
    if (thisyeardata) {
        $('#maincontent span[data-hasdata-thisyear]').hide().filter('[data-hasdata-thisyear="true"]').show();
    }
    else {
        $('#maincontent span[data-hasdata-thisyear]').hide().filter('[data-hasdata-thisyear="false"]').show();
        return;  // nothing else we can do until they select a year which has data
    }

    //
    // from here on out we know that we're showing a specific election/plan
    // and we have a lot of little things to fill in
    // we hand off to functions since it's rather a lot of lines to read as one giant block
    //

    // set the title
    updateMetricsTitle(thisyeardata);

    // a single sentence summarizing the 3 metric outcomes: 2 out of 3, they all agree, no consistency found, ...
    updateMetricsSummary(thisyeardata);

    // update the metric tabs: various sentences in each tab, and the tabs themselves
    updateMetricsTabs(thisyeardata);

    // Efficiency Gap: refresh the Wasted Votes chart
    updateWastedVotesChart(thisyeardata);

    // the bell charts indicating this plan's relative bias rating for each metric
    drawBiasBellCharts(thisyeardata);

    // update the map, showing the election outcomes / plan winners
    updateMapForCurrentSelection(thisyeardata);
};

window.updateMetricsTitle = (yeardata) => {
    const minyear = yeardata.plan_minyear;
    const maxyear = yeardata.plan_maxyear;
    const year    = yeardata.year;

    // compose a title for what we're seeing
    let title = `${minyear}-${maxyear} Redistricting Plan`;
    if (minyear == maxyear) {
        title = `${maxyear} Redistricting Plan`;  // don't say "2000-2000 plan"
    }
    if (CURRENT_VIEW.planorelection == 'election') {
        title = `${year} Election`;
    }

    // apply it
    $('#maincontent span[data-field="title"]').text(title);
};

window.updateMetricsSummary = (yeardata) => {
    // compose a sentence summarizing how many metrics indicate a bias one way or the other
    // e.g. "2 out of 3 metrics agree..." or "all metrics agree..."
    const eg_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const pb_score  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];
    const mm_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];

    const favor_party_eg = lookupBiasFavorParty(eg_score);
    const favor_party_pb = lookupBiasFavorParty(pb_score);
    const favor_party_mm = lookupBiasFavorParty(mm_score);

    // how many metrics favor D or R?
    const metrics_favor_d = [ favor_party_eg, favor_party_pb, favor_party_mm ].filter((party) => { return party == 'Democrat'; }).length;
    const metrics_favor_r = [ favor_party_eg, favor_party_pb, favor_party_mm ].filter((party) => { return party == 'Republican'; }).length;

    // compose the sentence, with 2 out of 3 being the minimum worth mentioning
    let biasstatement = "No consistent statistical bias was found among the three metrics.";
    if      (metrics_favor_d == 3) biasstatement = "All three metrics agree that there is a bias in favor of Democrat voters.";
    else if (metrics_favor_r == 3) biasstatement = "All three metrics agree that there is a bias in favor of Republican voters.";
    else if (metrics_favor_d == 2 && metrics_favor_r == 0) biasstatement = "Two of the three metrics indicate a bias in favor of Democrat voters.";
    else if (metrics_favor_r == 2 && metrics_favor_d == 0) biasstatement = "Two of the three metrics indicate a bias in favor of Reublican voters.";

    // fill it in
    $('#maincontent span[data-metric="biasstatement"]').text(biasstatement);
};

window.updateMetricsTabs = (yeardata) => {
    // fetch the seat counts, vote counts, bias metric scores, ... depending on whether we are showing a Plan or Election
    const eg_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const pb_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];
    const mm_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];
    const eg_rank     = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].egrank ];
    const bias_rank   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].biasrank ];
    const mmd_rank    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mmrank ];
    const seats_rep   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats_rep ];
    const seats_dem   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats_dem ];
    const totalseats  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats ];

    // for the selected year/plan
    // the 3 plan-bias metrics: do any of them show a bias toward D or R?
    // tag the biasicon icons in the metrics' tabs
    const favor_party_eg = lookupBiasFavorParty(eg_score);
    const favor_color_eg = lookupBiasColor(eg_score);
    const percent_eg     = `+${Math.round(100 * Math.abs(eg_score))}%`;
    const hadseats       = favor_party_eg == 'Republican' ? seats_rep : seats_dem;
    const statement_eg   = totalseats ? (favor_party_eg ? `${favor_party_eg}s needed ${(100 * Math.abs(eg_score)).toFixed(1)}% fewer votes to win their ${hadseats} of ${totalseats} seats.` : 'This metric indicates a balanced plan.') : '';
    const biastext_eg    = favor_party_eg ? `This plan is more biased than ${Math.round(100 * eg_rank)}% of the enacted plans we have analyzed nationwide.` : 'No consistent bias was found in favor of either party.';

    const favor_party_pb = lookupBiasFavorParty(pb_score);
    const favor_color_pb = lookupBiasColor(pb_score);
    const percent_pb     = `+${Math.round(100 * Math.abs(pb_score))}%`;
    const statement_pb   = favor_party_pb ? '' : 'This metric indicates a balanced plan.';
    const biastext_pb    = favor_party_pb ? `This plan is more biased than ${Math.round(100 * bias_rank)}% of the enacted plans we have analyzed nationwide.` : 'No consistent bias was found in favor of either party.';

    const favor_party_mm = lookupBiasFavorParty(mm_score);
    const favor_color_mm = lookupBiasColor(mm_score);
    const percent_mm     = `+${Math.round(100 * Math.abs(mm_score))}%`;
    const statement_mm   = favor_party_mm ? '' : 'This metric indicates a balanced plan.';
    const biastext_mm    = favor_party_mm ? `This plan is more biased than ${Math.round(100 * mmd_rank)}% of the enacted plans we have analyzed nationwide.` : 'No consistent bias was found in favor of either party.';

    // color the tab-swatches for the three metrics
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-efficiencygap"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democrat').text(' ');
        if (favor_party_eg) $swatch.addClass(`${favor_party_eg.toLowerCase()}`).text(favor_party_eg.substr(0,1).toUpperCase());
    }
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-partisanbias"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democrat').text(' ');
        if (favor_party_pb) $swatch.addClass(`${favor_party_pb.toLowerCase()}`).text(favor_party_pb.substr(0,1).toUpperCase());
    }
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-meanmedian"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democrat').text(' ');
        if (favor_party_mm) $swatch.addClass(`${favor_party_mm.toLowerCase()}`).text(favor_party_mm.substr(0,1).toUpperCase());
    }

    // fill in those +DR% numbers and the summary texts, at the top of the metric tabs
    $('#tab-efficiencygap span[data-field="metricpercent"]').text(percent_eg);
    $('#tab-efficiencygap span[data-field="metricparty"]').text(favor_party_eg ? favor_party_eg : 'Balanced');
    $('#tab-efficiencygap span[data-field="metricstatement"]').text(statement_eg);
    $('#tab-efficiencygap span[data-field="plancompare"]').text('This plan is more biased toward X than 100% all of the enacted plans we have analyzed nationwide.');
    $('#tab-efficiencygap span[data-field="biasstatement"]').text(biastext_eg);

    $('#tab-partisanbias span[data-field="metricpercent"]').text(percent_pb);
    $('#tab-partisanbias span[data-field="metricparty"]').text(favor_party_pb ? favor_party_pb : 'Balanced');
    $('#tab-partisanbias span[data-field="metricstatement"]').text(statement_pb);
    $('#tab-partisanbias span[data-field="plancompare"]').text('This plan is more biased toward X than 100% all of the enacted plans we have analyzed nationwide.');
    $('#tab-partisanbias span[data-field="biasstatement"]').text(biastext_pb);

    $('#tab-meanmedian span[data-field="metricpercent"]').text(percent_mm);
    $('#tab-meanmedian span[data-field="metricparty"]').text(favor_party_mm ? favor_party_mm : 'Balanced');
    $('#tab-meanmedian span[data-field="metricstatement"]').text(statement_mm);
    $('#tab-meanmedian span[data-field="plancompare"]').text('This plan is more biased toward X than 100% all of the enacted plans we have analyzed nationwide.');
    $('#tab-meanmedian span[data-field="biasstatement"]').text(biastext_mm);

    // color those +DR% boxes
    {
        const $sumbox = $('#tab-efficiencygap div.metricdrsum').removeClass('republican').removeClass('democrat').removeClass('balanced');
        if      (favor_party_eg == 'Republican') $sumbox.addClass('republican');
        else if (favor_party_eg == 'Democrat')   $sumbox.addClass('democrat');
        else                                     $sumbox.addClass('balanced');
    }
    {
        const $sumbox = $('#tab-partisanbias div.metricdrsum').removeClass('republican').removeClass('democrat').removeClass('balanced');
        if      (favor_party_pb == 'Republican') $sumbox.addClass('republican');
        else if (favor_party_pb == 'Democrat')   $sumbox.addClass('democrat');
        else                                     $sumbox.addClass('balanced');
    }
    {
        const $sumbox = $('#tab-meanmedian div.metricdrsum').removeClass('republican').removeClass('democrat').removeClass('balanced');
        if      (favor_party_mm == 'Republican') $sumbox.addClass('republican');
        else if (favor_party_mm == 'Democrat')   $sumbox.addClass('democrat');
        else                                     $sumbox.addClass('balanced');
    }
};

window.updateWastedVotesChart = (yeardata) => {
    // fetch the vote tallies for this election/plan
    const totalvotes = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_both ];
    const wasted_dem = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].wasted_dem ];
    const wasted_rep = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].wasted_rep ];
    const votes_dem  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_dem ];
    const votes_rep  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_rep ];

    // if there is no data on votes + wasted votes for this election/plan
    // then just hide this chart
    if (! totalvotes) {
        $('#chart-egvoteswasted').hide();
        return;
    }

    // construct the chart series
    const votechartdata = [
        {
            name: 'Votes Wasted',
            data: [0, 0],
            colors: [ WASTEDVOTE_CHART_WASTED_D, WASTEDVOTE_CHART_WASTED_R ],
        },
        {
            name: 'Votes Needed',
            data: [0, 0],
            colors: [ WASTEDVOTE_CHART_USEFUL_D, WASTEDVOTE_CHART_USEFUL_R ],
        }
    ];
    votechartdata[0].data[0] = wasted_dem;
    votechartdata[0].data[1] = wasted_rep;
    votechartdata[1].data[0] = votes_dem - wasted_dem;
    votechartdata[1].data[1] = votes_rep - wasted_rep;

    // now chart it
    // and show the chart, in case it was previously hidden
    $('#chart-egvoteswasted').show();
    Highcharts.chart('chart-egvoteswasted', {
        chart: {
            type: 'bar'
        },
        title: {
            text: 'Votes Needed and Wasted',
            margin:0,
        },
        xAxis: {
            categories: ['D', 'R']
        },
        yAxis: {
            min: 0,
            title: {
                enabled: false,
            },
            tickAmount: 4,
            showFirstLabel: false,
        },
        legend: {
            enabled: false,
        },
        tooltip: {
            formatter: function () {
                const party = this.point.category == 'D' ? 'Democrat' : 'Republican';
                return `${party}<br/>${this.y.toLocaleString()} ${this.series.name}`;
            },
        },
        plotOptions: {
            series: {
                stacking: 'normal',
                pointPadding: 0,
                groupPadding: 0,
                pointWidth: 25,
                colorByPoint: true,  // use the cvustom-assigned colors,
                animation: false,
            }
        },
        series: votechartdata,
    });
};

window.redrawYearPicker = (csvdata) => {
    // THE BIG/DESKTOP YEARPICKER
    // the big yearpicker has a button to select the given election year
    // but also the left-most dot-and-dash thing indicating when a new plan was enacted
    // while the years are a universal constant, the plan-enactment years depends on what district type we're discussing
    // so must be redrawn here
    {
        // a lookup dict: year => plan
        const yearplans = {};
        csvdata.forEach((row) => { yearplans[row.year] = row.plan; });

        // the A links on the plan side & year side
        const $planslinks = $('#yearpicker-big div.plans').find('a');
        const $yearslinks = $('#yearpicker-big div.elections').find('a');

        // go over each year in the universe (which was used to construct the $yearpicker_buttons) and find its row
        // tag the row as being plan-start or plan-continue, for CSS purposes
        PLAN_YEARS.slice().reverse().forEach((year, index, allyears) => {
            const thisyearplan = yearplans[year];
            const prevyearplan = yearplans[allyears[index+1]];
            const $planlink = $planslinks.filter(`[data-year="${year}"]`);
            const $yearlink = $yearslinks.filter(`[data-year="${year}"]`);
            // console.log([ year, thisyearplan, prevyearplan, thisyearplan !== prevyearplan ? 'newplan' : 'continue' ]);

            // tag the plan as either begin/continue
            // or if we have no data, hide both the plan and year links
            // use "thisyearplan" for both sides, since it would be filled in with a plan ID if we had any data at all
            if (thisyearplan) {
                $yearlink.show();
                $planlink.attr('data-plan', thisyearplan).show();  // used for click handling so we know what plan to load

                if (thisyearplan == prevyearplan) $planlink.removeClass('plan-begin').addClass('plan-continue').prop('title', 'Show details for this districting plan');
                else                              $planlink.removeClass('plan-continue').addClass('plan-begin').prop('title', `A new district plan was implemented in ${year}. Show details for this districting plan.`);
            }
            else {
                $yearlink.hide();
                $planlink.hide();
            }
        });

        // final touch: if were showing a plan then highlight the plan visually
        if (CURRENT_VIEW.planorelection == 'plan') {
            const $plinks = $('#yearpicker-big div.plans a').removeClass('active');
            const plan = $plinks.filter(`[data-year="${CURRENT_VIEW.year}"]`).first().attr('data-plan');
            $plinks.filter(`[data-plan="${plan}"]`).addClass('active');
        }
    }

    // THE SMALL/MOBILE YEARPICKER
    // update the election year readout, showing the selected year
    // as well as the next/prev buttons if we are now st the first/last
    {
        // show this year's readout
        const $picker    = $('#yearpicker-small > div[data-picker="election"]');
        const $yearlinks = $picker.find('> div.readout > span').hide();
        const $thislink  = $yearlinks.filter(`[data-year="${CURRENT_VIEW.year}"]`).show();
        const $prevbutton = $picker.find('i[data-role="prev"]');
        const $nextbutton = $picker.find('i[data-role="next"]');

        // detect first year and disable prev; detect last year and disable next
        if ($thislink.is(':first-child')) $prevbutton.hide();
        else                              $prevbutton.show();
        if ($thislink.is(':last-child'))  $nextbutton.hide();
        else                              $nextbutton.show();
    }

    // now the plan picker: a list of plans, and a data-year= of their starting year
    {

        const plans_known = {};
        csvdata.forEach((row) => {
            if (! plans_known[row.plan]) {
                plans_known[row.plan] = { plan: row.plan, minyear: row.plan_minyear, maxyear: row.plan_maxyear };
            }
        });

        const plans_listing = Object.values(plans_known);
        plans_listing.sort((p,q) => { return p.minyear < q.minyear ? -1 : 1; });

        const $picker = $('#yearpicker-small > div[data-picker="plan"]');

        const $readout = $picker.find('> div.readout').empty();
        plans_listing.forEach((planinfo) => {
            const text = planinfo.minyear == planinfo.maxyear ? `${planinfo.minyear} Districting Plan` : `${planinfo.minyear}-${planinfo.maxyear} Districting Plan`;
            $(`<span data-plan="${planinfo.plan}" data-year="${planinfo.minyear}" data-minyear="${planinfo.minyear}" data-maxyear="${planinfo.maxyear}">${text}</span>`).appendTo($readout).hide();
        });

        // show the selected year  (not easy: we have to find a range of minyear-maxyear, may not be an exact year that is offered)
        // detect first year and disable prev; detect last year and disable next
        const $prevbutton = $picker.find('i[data-role="prev"]');
        const $nextbutton = $picker.find('i[data-role="next"]');

        const $thislink = $readout.find('span').filter(function () {
            const $this = $(this);
            return $this.attr('data-minyear') <= CURRENT_VIEW.year && $this.attr('data-maxyear') >= CURRENT_VIEW.year;
        }).show();

        if ($thislink.is(':first-child')) $prevbutton.hide();
        else                              $prevbutton.show();
        if ($thislink.is(':last-child'))  $nextbutton.hide();
        else                              $nextbutton.show();
    }
};

window.drawBiasBellCharts = (yeardata) => {
    // just a wrapper around drawBiasBellChart as it's mostly identical for all 3 metrics
    const egscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const mmscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];
    const pbscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];

    drawBiasBellChart('eg', egscore);
    drawBiasBellChart('mm', mmscore);
    drawBiasBellChart('pb', pbscore);
};

window.drawBiasBellChart = (whichone, datavalue) => {
    // the bell charts are a bit of a trick, in that the real bellchart libs won't do what we need
    // this is a column chart with a single non-0 data point, to draw the black bar showing this plan's rating
    // the div.metric-bellchart has additional CSS classes, to use a colorful background-image which looks like a bell curve

    // replace CSS classes to change which curve image is being displayed as the backdrop
    const $div = $(`#metric-bellchart-${whichone}`).empty();
    $div.removeClass('pb').removeClass('eg').removeClass('mm').addClass(whichone);
    $div.removeClass('ushouse').removeClass('statehouse').removeClass('statesentate').addClass(CURRENT_VIEW.boundtype);
    $div.removeClass('election').removeClass('plan').addClass(CURRENT_VIEW.planorelection);

    // normalize the value into a range of 0% to 100% within that range, to form an X axis position
    // 0% is the furthest left; 100% furthest right; 50% balanced
    // watch out! we swap the sign here!
    // Republican bias is indicated with values <0 BUT in American parlance Republicans are "right" which is the positive-numbers side
    // so SUBTRACT the bias to shift a positive/democrat bias toward blue left
    const spread = BELLCURVE_SPREAD[whichone];
    let percentile = 0.5 - (0.5 * datavalue / spread);
    percentile = Math.min(Math.max(percentile, 0), 1);
    // console.log([ `drawBiasBellChart() ${whichone}`, spread, datavalue, percentile ]);
    $('<div class="markline"></div>').css({ 'left':`${100 * percentile}%` }).appendTo($div);
};

window.updateMapForCurrentSelection = (yeardata) => {
    const whichplan      = yeardata.plan;
    const whichlevel     = CURRENT_VIEW.boundtype;
    const whichyear      = CURRENT_VIEW.year;
    const planorelection = CURRENT_VIEW.planorelection;
    const geojsonurl     = `/data/districtpolygons/${whichlevel}-${whichplan}.json`;
    const csvurl         = '/data/elections_plans.csv';
    const statecode      = yeardata.state;
    // console.log([ 'updateMapForCurrentSelection', yeardata, CURRENT_VIEW.year, CURRENT_VIEW.boundtype, whichplan ]);

    // load the TopoJSON and set it up as the MAP's polygons layer
    // keep a reference to the layer so we can add/remove it
    $.get(geojsonurl, function (jsondata) {
        $('#map').show();

        if (MAP.polygondistrictsoverlay) {
            MAP.removeLayer(MAP.polygondistrictsoverlay);
        }

        MAP.polygondistrictsoverlay = new L.TopoJSON(jsondata, {
            style: MAP_DISTRICT_STYLE_DEFAULT,
        }).addTo(MAP);

        applyStylesToMapPolygons();
    }, 'json')
    .fail(function (error) {
        // on error, hide map: we have no geometry for this plan
        $('#map').hide();
    });

    // after loading the polygons, style them by election winner or plan winner
    // that data is in a CSV of all election+plan outcomes, we will filter to state
    // then style polygons by the relevant field
    function applyStylesToMapPolygons() {
        Papa.parse(csvurl, {
            download: true,
            header: true,
            complete: function (results) {
                // filter to year + state, or year + plan
                // filtering down the data in a separate step, makes it a lot easier to isolate the relevant results, separately from the polygon-style code later
                if (planorelection == 'election') {
                    // election year; filter by "year" and the "plan" field starting with this state code
                    results = results.data.filter((row) => {
                        return row.year == whichyear && row.plan.substr(0, 2) == statecode;
                    });
                }
                else {
                    // must be a plan; filter by the "plan" field
                    results = results.data.filter((row) => {
                        return row.plan == whichplan;
                    });
                }
                // console.log([ 'applyStylesToMapPolygons() results are:', results ]);

                // if there are 0 rows then we don't have election/plan data for the district polygons (if there are any of those either); if that's the case then hide the map
                if (results.length) {
                    $('#map').show();
                }
                else {
                    $('#map').hide();
                    return;
                }

                // go through the polygons and match their "DISTRICT" property to CSV's "district" field
                // then style them according to winner of that election or plan
                MAP.polygondistrictsoverlay.eachLayer(function (layer) {
                    const district_id = layer.feature.properties.DISTRICT;
                    const csvinfo = results.filter((row) => { return row.district == district_id; })[0];

                    if (! csvinfo) {
                        // this district on the map, has no corresponding entry in the election/plan data
                        layer.setStyle(MAP_DISTRICT_STYLE_DEFAULT);
                    }
                    else if (planorelection == 'election') {
                        // color by election winner
                        switch (csvinfo.winner) {
                            case 'D':
                                layer.setStyle(MAP_DISTRICT_STYLE_DEMOCRAT);
                                break;
                            case 'R':
                                layer.setStyle(MAP_DISTRICT_STYLE_REPUBLICAN);
                                break;
                            default:
                                layer.setStyle(MAP_DISTRICT_STYLE_DEFAULT);
                                break;
                        }
                    }
                    else {
                        // color by plan winner
                        switch (csvinfo.winner_plan) {
                            case 'D':
                                layer.setStyle(MAP_DISTRICT_STYLE_DEMOCRAT);
                                break;
                            case 'R':
                                layer.setStyle(MAP_DISTRICT_STYLE_REPUBLICAN);
                                break;
                            default:
                                layer.setStyle(MAP_DISTRICT_STYLE_DEFAULT);
                                break;
                        }
                    }
                });
            }, // end of CSV download
        });
    }
};

window.logMetricToggleToGoogleAnalytics = (whichmetric) => {
    if (! gtag) return;  // no Google Tag Manager = don't bother; this should be declared along with GTM

    gtag('event', 'metricdetails', {
        value: CURRENT_VIEW.year,
        event_category: whichmetric,
        event_label : `${CURRENT_VIEW.boundtype}-${CURRENT_VIEW.planorelection}`,
    });
};
