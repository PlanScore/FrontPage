// this page's HTML template with the [hash] cache-buster
// and the only stylesheet
require('./index.scss');
require('./index.src.html');

// shared constants between pages: the list of years, the red-blue color gradient, ...
import { PLAN_YEARS } from "./../planscore_common";
import { STATE_NAME_TO_CODE } from "./../planscore_common";
import { CONUS_BOUNDS } from "./../planscore_common";
import { STATE_BOUNDING_BOXES } from "./../planscore_common";
import { lookupBiasColor, lookupBiasFavorParty } from "./../planscore_common";

// bundle polyfills and local/vendor libraries specific to this page
//require('core-js/fn/array/includes');
require('./../jslibs/leaflet-control-zoombar.js');
require('./../jslibs/leaflet-control-zoombar.css');


//
// CONSTANTS
//

// the currently-visible state: boundary type + year, e.g. US House districts for 1984
// these are affected by window.selectXXX() family of functions which ultimately are all wrappers over loadDataForSelectedBoundaryAndYear()
const CURRENT_VIEW = {
    // NOTE that the values here are just indicative for documentation purposes
    // initLoadStartingConditions() parses the URL params and calls selectXXX() to set the actual defaults
    year: '2000',  // four-digit year (string)
    boundtype: 'ushouse',  // short polygon name: ushouse statehouse statesenate
    planorelection: 'election',  // show 'election' or 'plan' statistics on right-hand side
};

// Efficiency Gap wasted vote chart; colors
const WASTEDVOTE_CHART_WASTED_D = '#0049A8';
const WASTEDVOTE_CHART_WASTED_R = '#C71C36';
const WASTEDVOTE_CHART_USEFUL_D = '#99b7dc';
const WASTEDVOTE_CHART_USEFUL_R = '#e8a4ad';

// for the bellcurve charts, the data spread (min + max absolute values)
// so we can interpolate a value and position a marker line indicating a value
// see drawBiasBellChart()
const BELLCURVE_SPREAD = {
    eg: 0.22,
    mm: 0.11,
    pb: 0.30,
};

// what fields to use for Election Mode and Plan Mode
// each record contains bias-related statistics for both that specific election-year and the average of all years the plan was implemented
// e.g. mmd and mmd_avg, eg_percentrank and eg_avg_percentrank
// the various sub-systems from updateStatsFromCsvContent() will need to load "the bias field" based on whether CURRENT_VIEW.planorelection indicates that we want a Election Year or a Plan Overview
// example:   fetch the bias score from either 'the election field' or 'the plan field' as necessary
//            const relevantbiasfield = ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias;
//            const bias_score        = thisyeardata[relevantbiasfield];
// not all fields are listed here, just the ones which vary between election view and plan view
const ELECTION_PLAN_RECORD_FIELDS = {
    'election': {
        'eg': 'eg_adj',
        'egrank': 'eg_percentrank',
        'bias': 'bias',
        'biasrank': 'bias_percentrank',
        'mm': 'mmd',
        'mmrank': 'mmd_percentrank',
        'wasted_dem': 'wasted_dem',
        'wasted_rep': 'wasted_rep',
        'votes_dem': 'votes_dem',
        'votes_rep': 'votes_rep',
        'votes_both': 'votes_twop',
        'seats': 'seats',
        'seats_dem': 'seats_dem',
        'seats_rep': 'seats_r',
    },
    'plan': {
        'eg': 'eg_adj_avg',
        'egrank': 'eg_avg_percentrank',
        'bias': 'bias_avg',
        'biasrank': 'bias_avg_percentrank',
        'mm': 'mmd_avg',
        'mmrank': 'mmd_avg_percentrank',
        'wasted_rep': 'wasted_rep_plan',
        'wasted_dem': 'wasted_dem_plan',
        'votes_dem': 'votes_dem_plan',
        'votes_rep': 'votes_rep_plan',
        'votes_both': 'votes_twop_plan',
        'seats': 'seats_plan',
        'seats_dem': 'seats_dem_plan',
        'seats_rep': 'seats_r_plan',
    },
};

// the bounding box of this state
const STATE_BBOX = STATE_BOUNDING_BOXES[STATE_NAME_TO_CODE[SELECTED_STATE]];

// for the map of election winnders & plan winners, the styles
const MAP_POLYGON_STYLE_DEFAULT = {
    stroke: true, color: 'black', weight: 1,
    fill: false, // tip: transparent fill can be clicked; no fill cannot be clicked
    bubblingMouseEvents: false,
};
const MAP_POLYGON_STYLE_DEMOCRAT = {
    stroke: true, color: 'black', weight: 1,
    fill: true, fillColor: '#0049A8',
    bubblingMouseEvents: false,
};
const MAP_POLYGON_STYLE_REPUBLICAN = {
    stroke: true, color: 'black', weight: 1,
    fill: true, fillColor: '#C71C36',
    bubblingMouseEvents: false,
};


//
// PAGE STARTUP / INIT FUNCTIONS
//

$(document).ready(function () {
    // see also SELECTED_STATE declaration hardcoded into HTML template

    initYearPickers();
    initBoundaryPicker();
    initMap();
    initLoadStartingConditions();  // this will implicitly call loadDataForSelectedBoundaryAndYear() after setup, loading the map

    $(window).on('resize', handleResize);
    handleResize();
});

window.handleResize = () => {
    // various things that don't gracefully handle being resized, so we need to help them out
};

window.initMap = () => {
    // the map of the state, in its initial state with no data
    // basemap + labels at fixed zIndexes within the tilePane
    // simple zoom+home control
    // see also updateMapForCurrentSelection() which updates the map to the given election/plan/year

    window.MAP = L.map('map', {
        minZoom: 6,
        maxZoom: 11,
        zoomControl: false,
    }).fitBounds(STATE_BBOX);

    L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_nolabels/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
        subdomains: 'abcd',
        zIndex: 0,
    }).addTo(MAP);
    L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
        subdomains: 'abcd',
        zIndex: 99,
    }).addTo(MAP);

    new L.Control.ZoomBar({
        position: 'topright',
        homeBounds: STATE_BBOX,
    }).addTo(MAP);


    // more prep work: create L.TopoJSON which parses both GeoJSON and TopoJSON
    L.TopoJSON = L.GeoJSON.extend({
        addData: function(jsonData) {
            if (jsonData.type === "Topology") {
                for (var key in jsonData.objects) {
                    const geojson = topojson.feature(jsonData, jsonData.objects[key]);
                    L.GeoJSON.prototype.addData.call(this, geojson);
                }
            }    
            else {
                L.GeoJSON.prototype.addData.call(this, jsonData);
            }
        }
    });
};

window.initYearPickers = () => {
    // mobile
    // a simple SELECT to choose a year, and trigger selectElectionOrPlan()
    const $picker_small = $('#yearpicker-small');
    PLAN_YEARS.slice().reverse().forEach((year) => {
        const $group = $(`<optgroup label="${year}"></optgroup>`).appendTo($picker_small);
        $('<option></option>').text(`${year} Election Outcomes`).prop('value', `${year}-election`).appendTo($group);
        $('<option></option>').text(`${year} Redistricting Plan`).prop('value', `${year}-plan`).appendTo($group);
    });
    $picker_small.change(function () {
        const value = $(this).val();
        const year  = value.split('-')[0];
        const what  = value.split('-')[1];
        selectElectionOrPlan(year, what);
    });

    // desktop
    // the list of "year beads" running down the side
    // we can only do half of it here: the list of all election years (right-hand side)
    // since the plan timeline (left-hand side) depends on what dataset is selected; thus see also redrawYearPicker()
    const $picker_big   = $('#yearpicker-big');
    const $plansdiv     = $('<div class="plans col-xs-5"></div>').appendTo($picker_big);
    const $electionsdiv = $('<div class="elections col-xs-7"></div>').appendTo($picker_big);
    
    $('<span>Election<br>Years</span>').appendTo($electionsdiv);

    PLAN_YEARS.slice().reverse().forEach((year) => {
        $(`<a title="Show details for the ${year} election year"><span></span> ${year}</a>`).attr('data-year', year).appendTo($electionsdiv);
    });

    $electionsdiv.on('click', 'a', function () {
        const year = $(this).attr('data-year');
        selectElectionOrPlan(year, 'election');
    });

    $plansdiv.on('click', 'a', function () {
        const year = $(this).attr('data-year');
        selectElectionOrPlan(year, 'plan');
    });
};

window.initBoundaryPicker = () => {
    $('#boundarypicker div[data-boundary]').click(function () {
        const boundarytype = $(this).attr('data-boundary');
        selectBoundaryType(boundarytype);
    });
};

window.initLoadStartingConditions = () => {
    // analyze the #year-polytype hash to see what year + type we should load
    // see alsoupdateUrlHash() which generates this hash

    let year = PLAN_YEARS[PLAN_YEARS.length - 1];
    let what = 'election';
    let type = 'ushouse';

    const year_and_type = /^#!(\d\d\d\d)\-(\w+)\-(\w+)$/.exec(window.location.hash);
    if (year_and_type) {
        year = year_and_type[1];  // the year
        what = year_and_type[2];  // election or plan
        type = year_and_type[3];  // district type
    }

    // ready, set, go
    selectElectionOrPlan(year, what);
    selectBoundaryType(type);
};


//
// RUNTIME FUNCTIONS FOR CHANGING YEAR + DISTRICT TYPE
// loadDataForSelectedBoundaryAndYear() is the real worker here; the others are basically convenience functions
//

window.loadDataForSelectedBoundaryAndYear = () => {
    if (! CURRENT_VIEW.year || ! CURRENT_VIEW.boundtype) return;  // need both; during startup one will be blank, so avoid an error

    // fetch the CSV file and then use the callbacks to update the map
    const url = `/data/bias_${CURRENT_VIEW.boundtype}.csv`;
    Papa.parse(url, {
        download: true,
        header: true,
        complete: function (results) {
            // district type was implicitly "filtered" by which CSV was fetched; now filter by this state
            const alldataforthisstate = results.data.filter((row) => {
                return row.state == STATE_NAME_TO_CODE[SELECTED_STATE];
            });

            // data fixes
            results.data.forEach((row) => {
                // cast fields to integer
                [
                    'eg_adj', 'eg_adj_avg', 'eg_avg_percentrank', 'eg_percentrank',
                    'bias', 'bias_avg','bias_avg_percentrank', 'bias_percentrank',
                    'mmd', 'mmd_avg', 'mmd_avg_percentrank', 'mmd_percentrank',
                ].forEach((fieldname) => { row[fieldname] = parseFloat(row[fieldname]); });

                // cast fields to integer
                [
                    'votes_twop_plan', 'votes_twop', 'votes_dem_plan',  'votes_dem',
                    'wasted_dem_plan', 'wasted_dem',
                    'wasted_rep_plan', 'wasted_rep',
                    'seats_plan',  'seats',
                    'seats_dem_plan',  'seats_dem',
                    'seats_r_plan', 'seats_r',
                ].forEach((fieldname) => { row[fieldname] = parseInt(row[fieldname]); });

                // create the votes_rep and votes_rep_plan
                row.votes_rep_plan = row.votes_twop_plan - row.votes_dem_plan;
                row.votes_rep      = row.votes_twop - row.votes_dem;
            });

            // data fixes: go through the CSV and add a plan_minyear and plan_maxyear attribute
            // this is the min and max year in which that year's "plan" was in effect
            {
                // pass 1: 
                let plans_analyzed = {};
                results.data.forEach((row) => {
                    if (! plans_analyzed[row.plan]) {
                        // not seen this year before; assume this is the first and last year of this newly-found plan
                        plans_analyzed[row.plan] = { minyear: row.year, maxyear: row.year };
                    }
                    else {
                        // we've seen this plan, update the min and max if appropriate
                        if (row.year < plans_analyzed[row.plan].minyear) plans_analyzed[row.plan].minyear = row.year;
                        if (row.year > plans_analyzed[row.plan].maxyear) plans_analyzed[row.plan].maxyear = row.year;
                    }
                });

                // pass 2: go through the rows and update from the plans_analyzed
                results.data.forEach((row) => {
                    row.plan_minyear = plans_analyzed[row.plan].minyear;
                    row.plan_maxyear = plans_analyzed[row.plan].maxyear;
                });
            }

            // ready, set, go!
            updateStatsFromCsvContent(alldataforthisstate);
        },
        error: function () {
            // an error, meaning bad network or missing CSV
            // treat this the same as receiving 0 rows, so the UI states that it has no data
            updateStatsFromCsvContent([]);
        },
    });

    // update URL params to show the current search
    updateUrlHash();
};

window.updateUrlHash = () => {
    // update URL params to show the current search
    // see also initLoadStartingConditions() which will load such a state
    const hash = `#!${CURRENT_VIEW.year}-${CURRENT_VIEW.planorelection}-${CURRENT_VIEW.boundtype}`;
    window.location.replace(hash);
};

window.selectElectionOrPlan = (year, planorelection) => {
    // UI update: highlight this button or select this option
    $('#yearpicker-small').val(`${year}-${planorelection}`);

    // go through the election years (right side) and plan spans (left side)
    // and tag them to indicate what we're highlighting: this election year, or this districting plan
    const $elinks = $('#yearpicker-big div.elections a').removeClass('active');
    //const $plinks = $('#yearpicker-big div.plans a').removeClass('active');
    if (planorelection == 'election') {
        $elinks.filter(`[data-year="${year}"]`).addClass('active');
    }
    else {
        // the plans timeline is redrawn by loadDataForSelectedBoundaryAndYear() since it depends on what was selected
    }

    // save to the state and refresh the map + data
    CURRENT_VIEW.year = year;
    CURRENT_VIEW.planorelection = planorelection;
    loadDataForSelectedBoundaryAndYear();
};

window.selectBoundaryType = (boundtype) => {
    // UI update: highlight this button
    $('#boundarypicker div').removeClass('active').filter(`[data-boundary="${boundtype}"]`).addClass('active');

    // save to the state and refresh the map + data
    CURRENT_VIEW.boundtype = boundtype;
    loadDataForSelectedBoundaryAndYear();
};

window.updateStatsFromCsvContent = (allcsvdata) => {
    // handle a condition of no data at all for this whole district type, for any year
    if (allcsvdata.length) {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="true"]').show();
    }
    else {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="false"]').show();
        return;  // nothing else we can do until they select a district type with data
    }

    // okay so we have SOME data for this state + district type
    // how many distinct plans and years are listed for this district type?
    const distinct_years = {};
    const distinct_plans = {};
    allcsvdata.forEach((row) => {
        distinct_years[row.year] = true;
        distinct_plans[row.plan] = true;
    });
    $('span[data-metric="electioncount"]').text(Object.keys(distinct_years).length.toLocaleString());
    $('span[data-metric="plancount"]').text(Object.keys(distinct_plans).length.toLocaleString());

    // okay so we have SOME data for this state + district type
    // redraw the large yearpicker, indicating years in which a new plan was implemented
    redrawYearPicker(allcsvdata);

    // final check: do we have data for this district for the selected year?
    const thisyeardata = allcsvdata.filter((row) => { return row.year == CURRENT_VIEW.year; })[0];
    if (thisyeardata) {
        $('#maincontent span[data-hasdata-thisyear]').hide().filter('[data-hasdata-thisyear="true"]').show();
    }
    else {
        $('#maincontent span[data-hasdata-thisyear]').hide().filter('[data-hasdata-thisyear="false"]').show();
        return;  // nothing else we can do until they select a year which has data
    }

    //
    // from here on out we know that we're showing a specific election/plan
    // and we have a lot of little things to fill in
    // we hand off to functions since it's rather a lot of lines to read as one giant block
    //

    // set the title
    updateMetricsTitle(thisyeardata);

    // a single sentence summarizing the 3 metric outcomes: 2 out of 3, they all agree, no consistency found, ...
    updateMetricsSummary(thisyeardata);

    // update the metric tabs: various sentences in each tab, and the tabs themselves
    updateMetricsTabs(thisyeardata);

    // Efficiency Gap: refresh the Wasted Votes chart
    updateWastedVotesChart(thisyeardata);

    // the bell charts indicating this plan's relative bias rating for each metric
    drawBiasBellCharts(thisyeardata);

    // update the map, showing the election outcomes / plan winners
    updateMapForCurrentSelection(thisyeardata);
};

window.updateMetricsTitle = (yeardata) => {
    const minyear = yeardata.plan_minyear;
    const maxyear = yeardata.plan_maxyear;
    const year    = yeardata.year;

    // compose a title for what we're seeing
    let title = `${minyear}-${maxyear} Redistricting Plan`;
    if (minyear == maxyear) {
        title = `${maxyear} Redistricting Plan`;  // don't say "2000-2000 plan"
    }
    if (CURRENT_VIEW.planorelection == 'election') {
        title = `${title}: ${year} Election`;
    }

    // apply it
    $('#maincontent span[data-field="title"]').text(title);
};

window.updateMetricsSummary = (yeardata) => {
    // compose a sentence summarizing how many metrics indicate a bias one way or the other
    // e.g. "2 out of 3 metrics agree..." or "all metrics agree..."
    const eg_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const pb_score  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];
    const mm_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];

    const favor_party_eg = lookupBiasFavorParty(eg_score);
    const favor_party_pb = lookupBiasFavorParty(pb_score);
    const favor_party_mm = lookupBiasFavorParty(mm_score);

    // how many metrics favor D or R?
    const metrics_favor_d = [ favor_party_eg, favor_party_pb, favor_party_mm ].filter((party) => { return party == 'Democrat'; }).length;
    const metrics_favor_r = [ favor_party_eg, favor_party_pb, favor_party_mm ].filter((party) => { return party == 'Republican'; }).length;

    // compose the sentence, with 2 out of 3 being the minimum worth mentioning
    let biasstatement = "No consistent statistical bias was found among the three metrics.";
    if      (metrics_favor_d == 3) biasstatement = "All three metrics agree that there is a bias in favor of Democrat voters.";
    else if (metrics_favor_r == 3) biasstatement = "All three metrics agree that there is a bias in favor of Republican voters.";
    else if (metrics_favor_d == 2 && metrics_favor_r == 0) biasstatement = "Two of the three metrics indicate a bias in favor of Democrat voters.";
    else if (metrics_favor_r == 2 && metrics_favor_d == 0) biasstatement = "Two of the three metrics indicate a bias in favor of Reublican voters.";

    // fill it in
    $('#maincontent span[data-metric="biasstatement"]').text(biasstatement);
};

window.updateMetricsTabs = (yeardata) => {
    // fetch the seat counts, vote counts, bias metric scores, ... depending on whether we are showing a Plan or Election
    const eg_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const pb_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];
    const mm_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];
    const eg_rank     = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].egrank ];
    const bias_rank   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].biasrank ];
    const mmd_rank    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mmrank ];
    const seats_rep   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats_rep ];
    const seats_dem   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats_dem ];
    const totalseats  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats ];

    // for the selected year/plan
    // the 3 plan-bias metrics: do any of them show a bias toward D or R?
    // tag the biasicon icons in the metrics' tabs
    const favor_party_eg = lookupBiasFavorParty(eg_score);
    const favor_color_eg = lookupBiasColor(eg_score);
    const percent_eg     = `+${Math.round(100 * Math.abs(eg_score))}%`;
    const hadseats       = favor_party_eg == 'Republican' ? seats_rep : seats_dem;
    const statement_eg   = favor_party_eg ? `${favor_party_eg}s needed ${(100 * Math.abs(eg_score)).toFixed(1)}% fewer votes to win their ${hadseats} of ${totalseats} seats.` : 'This metric indicates a balanced plan.';
    const biastext_eg    = favor_party_eg ? `This plan is more biased than ${Math.round(100 * eg_rank)}% of the enacted plans we have analyzed nationwide.` : 'No consistent bias was found in favor of either party.';

    const favor_party_pb = lookupBiasFavorParty(pb_score);
    const favor_color_pb = lookupBiasColor(pb_score);
    const percent_pb     = `+${Math.round(100 * Math.abs(pb_score))}%`;
    const statement_pb   = favor_party_pb ? '' : 'This metric indicates a balanced plan.';
    const biastext_pb    = favor_party_pb ? `This plan is more biased than ${Math.round(100 * bias_rank)}% of the enacted plans we have analyzed nationwide.` : 'No consistent bias was found in favor of either party.';

    const favor_party_mm = lookupBiasFavorParty(mm_score);
    const favor_color_mm = lookupBiasColor(mm_score);
    const percent_mm     = `+${Math.round(100 * Math.abs(mm_score))}%`;
    const statement_mm   = favor_party_mm ? '' : 'This metric indicates a balanced plan.';
    const biastext_mm    = favor_party_mm ? `This plan is more biased than ${Math.round(100 * mmd_rank)}% of the enacted plans we have analyzed nationwide.` : 'No consistent bias was found in favor of either party.';

    // color the tab-swatches for the three metrics
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-efficiencygap"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democrat').text(' ');
        if (favor_party_eg) $swatch.addClass(`${favor_party_eg.toLowerCase()}`).text(favor_party_eg.substr(0,1).toUpperCase());
    }
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-partisanbias"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democrat').text(' ');
        if (favor_party_pb) $swatch.addClass(`${favor_party_pb.toLowerCase()}`).text(favor_party_pb.substr(0,1).toUpperCase());
    }
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-meanmedian"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democrat').text(' ');
        if (favor_party_mm) $swatch.addClass(`${favor_party_mm.toLowerCase()}`).text(favor_party_mm.substr(0,1).toUpperCase());
    }

    // fill in those +DR% numbers and the summary texts, at the top of the metric tabs
    $('#tab-efficiencygap span[data-field="metricpercent"]').text(percent_eg);
    $('#tab-efficiencygap span[data-field="metricparty"]').text(favor_party_eg ? favor_party_eg : 'Balanced');
    $('#tab-efficiencygap span[data-field="metricstatement"]').text(statement_eg);
    $('#tab-efficiencygap span[data-field="plancompare"]').text('This plan is more biased toward X than 100% all of the enacted plans we have analyzed nationwide.');
    $('#tab-efficiencygap span[data-field="biasstatement"]').text(biastext_eg);

    $('#tab-partisanbias span[data-field="metricpercent"]').text(percent_pb);
    $('#tab-partisanbias span[data-field="metricparty"]').text(favor_party_pb ? favor_party_pb : 'Balanced');
    $('#tab-partisanbias span[data-field="metricstatement"]').text(statement_pb);
    $('#tab-partisanbias span[data-field="plancompare"]').text('This plan is more biased toward X than 100% all of the enacted plans we have analyzed nationwide.');
    $('#tab-partisanbias span[data-field="biasstatement"]').text(biastext_pb);

    $('#tab-meanmedian span[data-field="metricpercent"]').text(percent_mm);
    $('#tab-meanmedian span[data-field="metricparty"]').text(favor_party_mm ? favor_party_mm : 'Balanced');
    $('#tab-meanmedian span[data-field="metricstatement"]').text(statement_mm);
    $('#tab-meanmedian span[data-field="plancompare"]').text('This plan is more biased toward X than 100% all of the enacted plans we have analyzed nationwide.');
    $('#tab-meanmedian span[data-field="biasstatement"]').text(biastext_mm);

    // color those +DR% boxes
    {
        const $sumbox = $('#tab-efficiencygap div.metricdrsum').removeClass('republican').removeClass('democrat').removeClass('balanced');
        if      (favor_party_eg == 'Republican') $sumbox.addClass('republican');
        else if (favor_party_eg == 'Democrat')   $sumbox.addClass('democrat');
        else                                     $sumbox.addClass('balanced');
    }
    {
        const $sumbox = $('#tab-partisanbias div.metricdrsum').removeClass('republican').removeClass('democrat').removeClass('balanced');
        if      (favor_party_pb == 'Republican') $sumbox.addClass('republican');
        else if (favor_party_pb == 'Democrat')   $sumbox.addClass('democrat');
        else                                     $sumbox.addClass('balanced');
    }
    {
        const $sumbox = $('#tab-meanmedian div.metricdrsum').removeClass('republican').removeClass('democrat').removeClass('balanced');
        if      (favor_party_mm == 'Republican') $sumbox.addClass('republican');
        else if (favor_party_mm == 'Democrat')   $sumbox.addClass('democrat');
        else                                     $sumbox.addClass('balanced');
    }
};

window.updateWastedVotesChart = (yeardata) => {
    // fetch the vote tallies for this election/plan
    const totalvotes = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_both ];
    const wasted_dem = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].wasted_dem ];
    const wasted_rep = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].wasted_rep ];
    const votes_dem  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_dem ];
    const votes_rep  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_rep ];

    // if there is no data on votes + wasted votes for this election/plan
    // then just hide this chart
    if (! totalvotes) {
        $('#chart-egvoteswasted').hide();
        return;
    }

    // construct the chart series
    const votechartdata = [
        {
            name: 'Votes Wasted',
            data: [0, 0],
            colors: [ WASTEDVOTE_CHART_WASTED_D, WASTEDVOTE_CHART_WASTED_R ],
        },
        {
            name: 'Votes Needed',
            data: [0, 0],
            colors: [ WASTEDVOTE_CHART_USEFUL_D, WASTEDVOTE_CHART_USEFUL_R ],
        }
    ];
    votechartdata[0].data[0] = wasted_dem;
    votechartdata[0].data[1] = wasted_rep;
    votechartdata[1].data[0] = votes_dem - wasted_dem;
    votechartdata[1].data[1] = votes_rep - wasted_rep;

    // now chart it
    // and show the chart, in case it was previously hidden
    $('#chart-egvoteswasted').show();
    Highcharts.chart('chart-egvoteswasted', {
        chart: {
            type: 'bar'
        },
        title: {
            text: 'Votes Needed and Wasted',
            margin:0,
        },
        xAxis: {
            categories: ['D', 'R']
        },
        yAxis: {
            min: 0,
            title: {
                enabled: false,
            },
            tickAmount: 4,
            showFirstLabel: false,
        },
        legend: {
            enabled: false,
        },
        tooltip: {
            formatter: function () {
                const party = this.point.category == 'D' ? 'Democrat' : 'Republican';
                return `${party}<br/>${this.y.toLocaleString()} ${this.series.name}`;
            },
        },
        plotOptions: {
            series: {
                stacking: 'normal',
                pointPadding: 0,
                groupPadding: 0,
                pointWidth: 25,
                colorByPoint: true,  // use the cvustom-assigned colors,
                animation: false,
            }
        },
        series: votechartdata,
    });
};

window.redrawYearPicker = (csvdata) => {
    // the big yearpicker has a button to select the given election year
    // but also the left-most dot-and-dash thing indicating when a new plan was enacted
    // while the years are a universal constant, the plan-enactment years depends on what district type we're discussing
    // so must be redrawn here

    // a lookup dict: year => plan
    const yearplans = {};
    csvdata.forEach((row) => { yearplans[row.year] = row.plan; });

    // the set of year-rows in the picker// the column containing the plans
    const $plansdiv = $('#yearpicker-big div.plans').empty();
    
    $('<span>Enacted<br>Plans</span>').appendTo($plansdiv);

    // go over each year in the universe (which was used to construct the $yearpicker_buttons) and find its row
    // tag the row as being plan-start or plan-continue, for CSS purposes
    PLAN_YEARS.slice().reverse().forEach((year, index, allyears) => {
        const thisyearplan = yearplans[year];
        const prevyearplan = yearplans[allyears[index+1]];
        // console.log([ year, thisyearplan, prevyearplan, thisyearplan !== prevyearplan ? 'newplan' : 'continue' ]);

        const $link = $(`<a data-year="${year}" data-plan="${thisyearplan}"><span></span></a>`).appendTo($plansdiv);
        if (thisyearplan == prevyearplan) $link.removeClass('plan-begin').addClass('plan-continue').prop('title', 'Show details for this districting plan');
        else                              $link.removeClass('plan-continue').addClass('plan-begin').prop('title', `A new district plan was implemented in ${year}. Show details for this districting plan.`);
    });

    // final touch: if were showing a plan then highlight the plan visually
    if (CURRENT_VIEW.planorelection == 'plan') {
        const $plinks = $('#yearpicker-big div.plans a').removeClass('active');
        const plan = $plinks.filter(`[data-year="${CURRENT_VIEW.year}"]`).first().attr('data-plan');
        $plinks.filter(`[data-plan="${plan}"]`).addClass('active');
    }
};

window.drawBiasBellCharts = (yeardata) => {
    // just a wrapper around drawBiasBellChart as it's mostly identical for all 3 metrics
    const egscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const mmscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];
    const pbscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];

    drawBiasBellChart('eg', egscore);
    drawBiasBellChart('mm', mmscore);
    drawBiasBellChart('pb', pbscore);
};

window.drawBiasBellChart = (whichone, datavalue) => {
    // the bell charts are a bit of a trick, in that the real bellchart libs won't do what we need
    // this is a column chart with a single non-0 data point, to draw the black bar showing this plan's rating
    // the div.metric-bellchart has additional CSS classes, to use a colorful background-image which looks like a bell curve

    // replace CSS classes to change which curve image is being displayed as the backdrop
    const $div = $(`#metric-bellchart-${whichone}`).empty();
    $div.removeClass('pb').removeClass('eg').removeClass('mm').addClass(whichone);
    $div.removeClass('ushouse').removeClass('statehouse').removeClass('statesentate').addClass(CURRENT_VIEW.boundtype);

    // normalize the value into a range of 0% to 100% within that range, to form an X axis position
    // 0% is the furthest left; 100% furthest right; 50% balanced
    // watch out! we swap the sign here!
    // Republican bias is indicated with values <0 BUT in American parlance Republicans are "right" which is the positive-numbers side
    // so SUBTRACT the bias to shift a positive/democrat bias toward blue left
    const spread = BELLCURVE_SPREAD[whichone];
    const percentile = 0.5 - (0.5 * datavalue / spread);
    // console.log([ `drawBiasBellChart() ${whichone}`, spread, datavalue, percentile ]);
    $('<div class="markline"></div>').css({ 'left':`${100 * percentile}%` }).appendTo($div);
};

window.updateMapForCurrentSelection = (yeardata) => {
    const whichplan  = yeardata.plan;
    const whichlevel = CURRENT_VIEW.boundtype;
    const geojsonurl = `/data/districtpolygons/${whichlevel}-${whichplan}.json`;
    const csvurl     = '/data/elections_plans.csv';
    const statecode  = yeardata.state;
    const whichyear  = CURRENT_VIEW.year;
    const boundtype  = CURRENT_VIEW.boundtype;
    // console.log([ 'updateMapForCurrentSelection', yeardata, CURRENT_VIEW.year, CURRENT_VIEW.boundtype, whichplan ]);

    // load the TopoJSON and set it up as the MAP's poylgons layer, but only if we have in fact selected a different one
    // keep a reference to the layer so we can add/remove it
    // and also a "geojsonurl" attribute on it so we can check that we're just continuing to use the same polygons
    if (! MAP.polygondistrictsoverlay || MAP.polygondistrictsoverlay.geojsonurl != geojsonurl) {
        if (MAP.polygondistrictsoverlay) {
            MAP.removeLayer(MAP.polygondistrictsoverlay);
            MAP.polygondistrictsoverlay = undefined;
        }

        $.get(geojsonurl, function (jsondata) {
            MAP.polygondistrictsoverlay = new L.TopoJSON(jsondata, {
                style: MAP_POLYGON_STYLE_DEFAULT,
            });
            MAP.polygondistrictsoverlay.geojsonurl = geojsonurl;
            MAP.polygondistrictsoverlay.addTo(MAP);

            applyStylesToMapPolygons();
        }, 'json');
        MAP.geojsonurl = geojsonurl;
    }
    else {
        // we have an overlay and it's the same boundaries we're already showing
        // just apply styling base don new data
        applyStylesToMapPolygons();
    }

    // after loading the polygons, style them by election winner or plan winner
    // that data is in a CSV of all election+plan outcomes, we will filter to state
    // then style polygons by the relevant field
    function applyStylesToMapPolygons() {
        Papa.parse(csvurl, {
            download: true,
            header: true,
            complete: function (results) {
                // filter to year + state, or year + plan
                if (boundtype == 'election') {
                    // election year; filter by "year" and the "plan" field starting with this state code
                    results.data = results.data.filter((row) => {
                        return row.year == whichyear && row.plan.substr(0, 2) == statecode;
                    });
                }
                else {
                    // must be a plan; filter by the "plan" field
                    results.data = results.data.filter((row) => {
                        return row.plan == whichplan;
                    });
                }

console.log(results);
            },
        });
    }
};
