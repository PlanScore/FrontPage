// this page's HTML template with the [hash] cache-buster
// and the only stylesheet
require('./index.scss');
require('./index.src.html');

// shared constants between pages: the list of years, the red-blue color gradient, ...
import { PLAN_YEARS } from "./../_common/constants";
import { PLAN_YEARS_PER_STATE } from "./../_common/constants";
import { STATE_NAME_TO_CODE } from "./../_common/constants";
import { CONUS_BOUNDS } from "./../_common/constants";
import { STATE_BOUNDING_BOXES } from "./../_common/constants";
import { WASTEDVOTE_CHART_WASTED_D } from "./../_common/constants";
import { WASTEDVOTE_CHART_WASTED_R } from "./../_common/constants";
import { WASTEDVOTE_CHART_USEFUL_D } from "./../_common/constants";
import { WASTEDVOTE_CHART_USEFUL_R } from "./../_common/constants";
import { lookupBias } from "./../_common/functions";
import { drawBiasBellChart } from "./../_common/functions";

// bundle polyfills and local/vendor libraries specific to this page
require('core-js/fn/object/values');
require('core-js/fn/object/entries');
require('./../_common/jslibs/leaflet-control-zoombar.js');
require('./../_common/jslibs/leaflet-control-zoombar.css');
require('./../_common/jslibs/leaflet-control-partylegend.js');
require('./../_common/jslibs/leaflet-control-partylegend.css');
require('./../_common/jslibs/leaflet-polygon.fillPattern.js');


//
// CONSTANTS
//

// the currently-visible state: boundary type + year, e.g. US House districts for 1984
// these are affected by window.selectXXX() family of functions which ultimately are all wrappers over loadDataForSelectedBoundaryAndYear()
const CURRENT_VIEW = {
    // year: '2000',  // four-digit year (string)
    // boundtype: 'ushouse',  // short polygon name: ushouse statehouse statesenate
    // planorelection: 'election',  // show 'election' or 'plan' statistics on right-hand side
    // metric: 'eg', // which metric tab is showing?
};

// what fields to use for Election Mode and Plan Mode
// each record contains bias-related statistics for both that specific election-year and the average of all years the plan was implemented
// e.g. mmd and mmd_avg, eg_percentrank and eg_avg_percentrank
// the various sub-systems from updateStatsFromCsvContent() will need to load "the bias field" based on whether CURRENT_VIEW.planorelection indicates that we want a Election Year or a Plan Overview
// example:   fetch the bias score from either 'the election field' or 'the plan field' as necessary
//            const relevantbiasfield = ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias;
//            const bias_score        = thisyeardata[relevantbiasfield];
// not all fields are listed here, just the ones which vary between election view and plan view
const ELECTION_PLAN_RECORD_FIELDS = {
    'election': {
        // NOTE per https://github.com/PlanScore/PlanScore/issues/94, the 6 per-election fields (eg, bias, mm + rank) are stripped from CSVs to make them more compact downloads, until we reinstate election-year displays
        'eg': 'eg_adj',
        'egrank': 'eg_percentrank',
        'bias': 'bias',
        'biasrank': 'bias_percentrank',
        'mm': 'mmd',
        'mmrank': 'mmd_percentrank',
        'wasted_dem': 'wasted_dem',
        'wasted_rep': 'wasted_rep',
        'votes_dem': 'votes_dem',
        'votes_rep': 'votes_rep',
        'votes_both': 'votes_twop',
        'seats': 'seats',
        'seats_dem': 'seats_dem',
        'seats_rep': 'seats_r',
    },
    'plan': {
        'eg': 'eg_adj_avg',
        'egrank': 'eg_avg_percentrank',
        'bias': 'bias_avg',
        'biasrank': 'bias_avg_percentrank',
        'mm': 'mmd_avg',
        'mmrank': 'mmd_avg_percentrank',
        'wasted_rep': 'wasted_rep_plan',
        'wasted_dem': 'wasted_dem_plan',
        'votes_dem': 'votes_dem_plan',
        'votes_rep': 'votes_rep_plan',
        'votes_both': 'votes_twop_plan',
        'seats': 'seats_plan',
        'seats_dem': 'seats_dem_plan',
        'seats_rep': 'seats_r_plan',
    },
};

// the bounding box of this state
const STATE_BBOX = STATE_BOUNDING_BOXES[STATE_NAME_TO_CODE[SELECTED_STATE]];

// for the map of election winnders & plan winners, the styles
const MAP_DISTRICT_STYLE_DEFAULT = {
    stroke: true, color: '#999999', weight: 1,
    fill: true, fillColor: '#cccccc', fillOpacity: 0.6,
    bubblingMouseEvents: false,
    clickable: false,
};
const MAP_DISTRICT_STYLE_MIXED = {
    stroke: true, color: '#cccccc', weight: 1,
    fill: "url(/images/mapfill_nodata.png)", fillColor: 'transparent', fillOpacity: 0.6,  // crosshatch image fill, thanks to leaflet-polygon.fillPattern.js
    bubblingMouseEvents: false,
    clickable: false,
};
const MAP_DISTRICT_STYLE_DEMOCRAT = {
    stroke: true, color: '#cccccc', weight: 1,
    fill: true, fillColor: '#0049A8', fillOpacity: 0.6,
    bubblingMouseEvents: false,
    clickable: false,
};
const MAP_DISTRICT_STYLE_REPUBLICAN = {
    stroke: true, color: '#cccccc', weight: 1,
    fill: true, fillColor: '#C71C36', fillOpacity: 0.6,
    bubblingMouseEvents: false,
    clickable: false,
};


//
// PAGE STARTUP / INIT FUNCTIONS
//

$(document).ready(function () {
    // see also SELECTED_STATE declaration hardcoded into HTML template

    initYearPickers();
    initBoundaryPicker();
    initMap();
    initMetricTabTracking();
    initLoadStartingConditions();  // this will implicitly call loadDataForSelectedBoundaryAndYear() after setup, loading the map

    $(window).on('resize', handleResize);
    handleResize();
});

window.handleResize = () => {
    // various things that don't gracefully handle being resized, so we need to help them out
};

window.initMap = () => {
    // the map of the state, in its initial state with no data
    // basemap + labels with some hacks on the pane-and-zindex of the labels
    // simple zoom+home control
    // see also updateMapForCurrentSelection() which updates the map to the given election/plan/year

    window.MAP = L.map('map', {
        minZoom: 4,
        maxZoom: 11,
        zoomControl: false,
        scrollWheelZoom: false,
    }).fitBounds(STATE_BBOX);

    L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_nolabels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
        subdomains: 'abcd',
    }).addTo(MAP);
    L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-labels/{z}/{x}/{y}{r}.png', {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.',
        subdomains: 'abcd',
        pane: 'markerPane',
    }).addTo(MAP);

    new L.Control.ZoomBar({
        position: 'topright',
        homeBounds: STATE_BBOX,
    }).addTo(MAP);

    new L.Control.PartyLegend({
        position: 'topleft',
    }).addTo(MAP);

    // more prep work: create L.TopoJSON which parses both GeoJSON and TopoJSON
    L.TopoJSON = L.GeoJSON.extend({
        addData: function(jsonData) {
            if (jsonData.type === "Topology") {
                for (var key in jsonData.objects) {
                    const geojson = topojson.feature(jsonData, jsonData.objects[key]);
                    L.GeoJSON.prototype.addData.call(this, geojson);
                }
            }
            else {
                L.GeoJSON.prototype.addData.call(this, jsonData);
            }
        }
    });
};

window.initYearPickers = () => {
    // there are two separate UIs: the mobile one with "< year >" and a prev/next behavior
    // and the desktop one forming a set of beads down the side (with colors indicating EG bias that year)

    // this basically just sets the delegated event handlers, when the pickers' beads/arrows are clicked
    // per https://github.com/PlanScore/PlanScore/issues/217, most of the work is in redrawYearPickers()
    // the years offered are once again based on the years in the CSV data for the selected districttype-and-state
    // since it turns out that not all states have the same years, or may not have the same years between the different district types

    // note too that we still support showing Plan data or Election-year data
    // even though the display of Election-level data is presently disabled (https://github.com/PlanScore/PlanScore/issues/94) but likely to come back

    // mobile yearpicker
    const $planpicker_mobile  = $('#yearpicker-small > div[data-picker="plan"]');
    const $yearpicker_mobile  = $('#yearpicker-small > div[data-picker="election"]');
    const $yearlisting_mobile = $yearpicker_mobile.find('div.readout');
    const $planlisting_mobile = $planpicker_mobile.find('div.readout');

    $yearpicker_mobile.on('click', 'div.nextprev.right', function () {
        const $targetbutton = $yearlisting_mobile.find('span:visible').next('span');
        const year = $targetbutton.attr('data-year');
        if (! year) return;  // don't allow clicking past the first/last
        selectElectionOrPlan(year, 'election');
    });
    $yearpicker_mobile.on('click', 'div.nextprev.left', function () {
        const $targetbutton = $yearlisting_mobile.find('span:visible').prev('span');
        const year = $targetbutton.attr('data-year');
        if (! year) return;  // don't allow clicking past the first/last
        selectElectionOrPlan(year, 'election');
    });
    $planpicker_mobile.on('click', 'div.nextprev.right', function () {
        const $targetbutton = $planlisting_mobile.find('span:visible').next('span');
        const year = $targetbutton.attr('data-year');
        selectElectionOrPlan(year, 'plan');
    });
    $planpicker_mobile.on('click', 'div.nextprev.left', function () {
        const $targetbutton = $planlisting_mobile.find('span:visible').prev('span');
        const year = $targetbutton.attr('data-year');
        selectElectionOrPlan(year, 'plan');
    });

    // desktop yearpicker
    const $planpicker_desktop  = $('#yearpicker-big');
    const $planlisting_desktop = $planpicker_desktop.find('div.plans');
    const $yearlisting_desktop = $planpicker_desktop.find('div.elections');

    $yearlisting_desktop.on('click', 'a', function () {
        const year = $(this).attr('data-year');
        // https://github.com/PlanScore/PlanScore/issues/94: for the time being, years also go to Plans and not election-year details
        //selectElectionOrPlan(year, 'election');
        selectElectionOrPlan(year, 'plan');
    });
    $planlisting_desktop.on('click', 'a', function () {
        const year = $(this).attr('data-year');
        selectElectionOrPlan(year, 'plan');
    });
};

window.initBoundaryPicker = () => {
    $('#boundarypicker div[data-boundary]').click(function () {
        const boundarytype = $(this).attr('data-boundary');
        selectBoundaryType(boundarytype);
    });
};

window.initMetricTabTracking = () => {
    // when they switch metrics tabs, log a Google Analytics event
    $('#tabs-metrics a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
        const whichtab = $(e.target).prop('href').replace(/.+#tab-/, '');  // the suffix is the metric name, e.g. #tab-efficiencygap
        logMetricToggleToGoogleAnalytics(whichtab);
    });

    // when metric tab is switched, also track that in the CURRENT_VIEW; see also selectMetric() which may be relevant
    $('#tabs-metrics a[data-toggle="tab"]').on('shown.bs.tab', function (e, p, q) {
        const whichmetric = $(e.target).attr('data-metric');  // the suffix is the metric name, e.g. #tab-efficiencygap
        CURRENT_VIEW.metric = whichmetric;
        updateUrlHash();
    });
};

window.initLoadStartingConditions = () => {
    // analyze the #!year-polytype hash to see what year + district we should load
    // see alsoupdateUrlHash() which generates this hash

    const params   = window.location.hash.replace(/^#!/, '').split('-');
    const year     = params.shift() || PLAN_YEARS[PLAN_YEARS.length - 1];
    const planyear = params.shift() || 'plan';
    const district = params.shift() || 'ushouse';
    const metric   = params.shift() || 'eg';

    // toggle which yearpicker-small is displayed
    // per https://github.com/PlanScore/PlanScore/issues/129 only one of these is visible and that depends on whether the page loads with a plan/election
    $('#yearpicker-small > div').hide().filter(`[data-picker="${planyear}"]`).show();

    // ready, set, go
    selectMetric(metric);
    selectElectionOrPlan(year, planyear);
    selectBoundaryType(district);
};


//
// RUNTIME FUNCTIONS FOR CHANGING YEAR + DISTRICT TYPE
// loadDataForSelectedBoundaryAndYear() is the real worker here; the others are basically convenience functions
//

window.loadDataForSelectedBoundaryAndYear = (options={}) => {
    if (! CURRENT_VIEW.year || ! CURRENT_VIEW.boundtype) return;  // need both; during startup one will be blank, so this check avoids an error during startup when we're defining one then the other

    // options provides a special case for when the page loads (inspired by https://github.com/PlanScore/PlanScore/issues/223)
    // that if we have no data for the selected year, we figure out a better year and then forward them there
    // that's actually done in updateStatsFromCsvContent()

    // fetch the CSV file and then use the callbacks to update the map
    const url = `/data/bias_${CURRENT_VIEW.boundtype}.csv`;
    Papa.parse(url, {
        download: true,
        header: true,
        complete: function (results) {
            // district type was implicitly "filtered" by which CSV was fetched; now filter by this state
            const alldataforthisstate = results.data.filter((row) => {
                return row.state == STATE_NAME_TO_CODE[SELECTED_STATE];
            });

            // data fixes
            results.data.forEach((row) => {
                // cast fields to integer
                [
                    'eg_adj', 'eg_adj_avg', 'eg_avg_percentrank', 'eg_percentrank',
                    'bias', 'bias_avg','bias_avg_percentrank', 'bias_percentrank',
                    'mmd', 'mmd_avg', 'mmd_avg_percentrank', 'mmd_percentrank',
                ].forEach((fieldname) => { row[fieldname] = parseFloat(row[fieldname]); });

                // cast fields to integer
                [
                    'votes_twop_plan', 'votes_twop', 'votes_dem_plan',  'votes_dem',
                    'wasted_dem_plan', 'wasted_dem',
                    'wasted_rep_plan', 'wasted_rep',
                    'seats_plan',  'seats',
                    'seats_dem_plan',  'seats_dem',
                    'seats_r_plan', 'seats_r',
                ].forEach((fieldname) => { row[fieldname] = parseInt(row[fieldname]); });

                // create the votes_rep and votes_rep_plan
                row.votes_rep_plan = row.votes_twop_plan - row.votes_dem_plan;
                row.votes_rep      = row.votes_twop - row.votes_dem;
            });

            // data fixes: go through the CSV and add a plan_minyear and plan_maxyear attribute
            // this is the min and max year in which that year's "plan" was in effect
            {
                // pass 1:
                let plans_analyzed = {};
                results.data.forEach((row) => {
                    if (! plans_analyzed[row.plan]) {
                        // not seen this year before; assume this is the first and last year of this newly-found plan
                        plans_analyzed[row.plan] = { minyear: row.year, maxyear: row.year };
                    }
                    else {
                        // we've seen this plan, update the min and max if appropriate
                        if (row.year < plans_analyzed[row.plan].minyear) plans_analyzed[row.plan].minyear = row.year;
                        if (row.year > plans_analyzed[row.plan].maxyear) plans_analyzed[row.plan].maxyear = row.year;
                    }
                });

                // pass 2: go through the rows and update from the plans_analyzed
                results.data.forEach((row) => {
                    row.plan_minyear = plans_analyzed[row.plan].minyear;
                    row.plan_maxyear = plans_analyzed[row.plan].maxyear;
                });
            }

            // ready, set, go!
            updateStatsFromCsvContent(alldataforthisstate, options);

            // log the GA request
            logRequestToGoogleAnalytics();
        },
        error: function () {
            // an error, meaning bad network or missing CSV
            // treat this the same as receiving 0 rows, so the UI states that it has no data
            updateStatsFromCsvContent([], options);
        },
    });

    // update URL params to show the current search
    updateUrlHash();
};

window.logRequestToGoogleAnalytics = () => {
    if (! gtag) return;  // no Google Tag Manager = don't bother; this should be declared along with GTM

    gtag('event', 'statedetails', {
        name: STATE_NAME_TO_CODE[SELECTED_STATE],
        value: CURRENT_VIEW.year,
        event_category: CURRENT_VIEW.planorelection,
        event_label : CURRENT_VIEW.boundtype,
    });
};

window.updateUrlHash = () => {
    // update URL params to show the current search
    // see also initLoadStartingConditions() which will load such a state
    const hash = `#!${CURRENT_VIEW.year}-${CURRENT_VIEW.planorelection}-${CURRENT_VIEW.boundtype}-${CURRENT_VIEW.metric}`;
    window.location.replace(hash);
};

window.selectMetric = (whichmetric) => {
    // click the metric tab for them, and save to the state
    // see also initMetricTabTracking() which is perhaps relevant to these tabs being clicked
    $(`#tabs-metrics a[data-metric="${whichmetric}"]`).click();
    CURRENT_VIEW.metric = whichmetric;
    updateUrlHash();
};

window.selectElectionOrPlan = (year, planorelection, options={}) => {
    // not supplied = fill it in
    if (! planorelection) planorelection = CURRENT_VIEW.planorelection;

    // UI update: highlight this button or select this option
    $('#yearpicker-small').val(`${year}-${planorelection}`);

    // go through the election years (right side) and plan spans (left side)
    // and tag them to indicate what we're highlighting: this election year, or this districting plan
    const $elinks = $('#yearpicker-big div.elections a').removeClass('active');
    //const $plinks = $('#yearpicker-big div.plans a').removeClass('active');
    if (planorelection == 'election') {
        $elinks.filter(`[data-year="${year}"]`).addClass('active');
    }
    else {
        // the plans timeline is redrawn by loadDataForSelectedBoundaryAndYear() since it depends on what was selected
    }

    // save to the state and refresh the map + data
    CURRENT_VIEW.year = year;
    CURRENT_VIEW.planorelection = planorelection;
    loadDataForSelectedBoundaryAndYear(options);
};

window.selectBoundaryType = (boundtype, options={}) => {
    // UI update: highlight this button
    $('#boundarypicker div').removeClass('active').filter(`[data-boundary="${boundtype}"]`).addClass('active');

    // save to the state and refresh the map + data
    CURRENT_VIEW.boundtype = boundtype;
    loadDataForSelectedBoundaryAndYear(options);
};

window.updateStatsFromCsvContent = (allcsvdata, options={}) => {
    // options provides a special case for when the page loads (inspired by https://github.com/PlanScore/PlanScore/issues/223)
    // that if we have no data for the selected year, we figure out a better year and then forward them there
    // that's actually done in updateStatsFromCsvContent()

    // handle a condition of no data at all for this whole district type, for any year ever
    if (allcsvdata.length) {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="true"]').show();
        $('#sidebar span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="true"]').show();
    }
    else {
        $('#maincontent span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="false"]').show();
        $('#sidebar span[data-hasdata-atall]').hide().filter('[data-hasdata-atall="false"]').show();
        return;  // nothing else we can do until they select a district type with data
    }

    // okay so we have SOME data for this state + district type
    // how many distinct plans and years are listed for this district type?
    const distinct_years = {};
    const distinct_plans = {};
    allcsvdata.forEach((row) => {
        distinct_years[row.year] = true;
        distinct_plans[row.plan] = true;
    });
    $('span[data-metric="electioncount"]').text(Object.keys(distinct_years).length.toLocaleString());
    $('span[data-metric="plancount"]').text(Object.keys(distinct_plans).length.toLocaleString());

    // extract the data for the selected year; that logic depends on whether we're in Plan mode or Election mode
    // we may or may not get data; toggle the data-hasdata-thisyear elements accordingly
    let thisyeardata;
    switch (CURRENT_VIEW.planorelection) {
        case 'plan':
            thisyeardata = getDataForThisYear_Plan(allcsvdata, CURRENT_VIEW.year, options);
            break;
        case 'election':
            thisyeardata = getDataForThisYear_Election(allcsvdata, CURRENT_VIEW.year, options);
            break;
        default:
            throw new Error(`updateStatsFromCsvContent() unexpected CURRENT_VIEW.planorelection value: ${CURRENT_VIEW.planorelection}`);
    }

    redrawYearPickers(allcsvdata, thisyeardata);  // do this after getting thisyeardata so it can adapt to what we're showing, but before we bail with nodata below

    if (! thisyeardata) {
        // no data for this year = find closest year with data, offer it as a Did You Mean? sort of thing
        $('#maincontent span[data-hasdata-thisyear]').hide().filter('[data-hasdata-thisyear="false"]').show();
        $('#yearpicker-small').addClass('hidden'); // outside of #maincontent and mobile only but is broken if no data

        const closestyear = findClosestYear(allcsvdata, CURRENT_VIEW.year);
        const $link = $('#maincontent span[data-hasdata-thisyear="false"] a');
        $link.attr('data-year', closestyear);
        $link.find('span[data-field="closestyear"]').text(closestyear);

        return;  // nothing else we can do until they select a year which has data
    }

    $('#maincontent span[data-hasdata-thisyear]').hide().filter('[data-hasdata-thisyear="true"]').show();
    $('#yearpicker-small').removeClass('hidden'); // outside of #maincontent and mobile only but is broken if no data

    //
    // from here on out we know that we're showing a specific election/plan
    // and we have a lot of little things to fill in
    // we hand off to functions since it's rather a lot of lines to read as one giant block
    //

    // set the title
    updateMetricsTitle(thisyeardata);

    // a single sentence summarizing the 3 metric outcomes: 2 out of 3, they all agree, no consistency found, ...
    updateMetricsSummary(thisyeardata);

    // update the metric tabs: various sentences in each tab, and the tabs themselves
    updateMetricsTabs(thisyeardata);

    // refresh some charts: Efficiency Gap Wasted Votes, Partisan Bias Seat Share
    updateWastedVotesChart(thisyeardata);
    updateSeatShareChart(thisyeardata);

    // the bell charts indicating this plan's relative bias rating for each metric
    drawBiasBellCharts(thisyeardata);

    // update the map, showing the election outcomes / plan winners
    updateMapForCurrentSelection(thisyeardata);
};

window.findClosestYear = (allcsvdata, desiredyear) => {
    const wehavetheseyears = allcsvdata.map((row) => {
        return parseInt(row.year);
    });
    wehavetheseyears.sort((p, q) => {
        const px = Math.abs(p - parseInt(desiredyear));
        const qx = Math.abs(q - parseInt(desiredyear));
        return (px != qx) ? (px > qx ? 1 : -1) : (p > q ? -1 : 1); // order by diff from desired year; or else by higher-year if equal spread
    });
    return wehavetheseyears[0];
};

// called from updateStatsFromCsvContent() to encapsulate some logic for extracting the data relevant to this year
// Plan is a range of years, and per issues 223 and 241 the desired hehavior is to select the Plan in effect at that time even if it doesn't match the year
// and also rewrite the row so "year" field matches the request (as opposed to previous year-fudging techniques e.g. selectPlanYearIfNoData)
// in the case of Plans, we will always return a data row, even if we had to pick a year "surrounding" this one, or the first/last plan in the case of out-of-bounds years
window.getDataForThisYear_Plan = (allcsvdata, desiredyear, options={}) => {
    // all rows of the same Plan have the same Plan-related stats, so it doesn't much matter which row we pick

    // can't use minyear and maxyear here, because we have to account for years that are between plans, e.g. 1997 falls in between a 1994-1996 plan and a 1998-2000 plan
    // workaround: the latest plan with a maxyear <= the desiredyear ... which does imply that the rows are sorted which we shouldn't presume
    let plansnotyetexpired = allcsvdata.filter((row) => {
        return row.plan_minyear <= desiredyear;
    });
    plansnotyetexpired.sort((p, q) => { return p.year <= q.year ? 1 : -1; });  // recent-to-oldest, so 0 is most recent which hadn't yet expired at this time

    if (plansnotyetexpired.length) {
        const datarow = plansnotyetexpired[0];
        return datarow;
    }

    // the above case would also catch a year that was out-of-bounds by being too high (the year 2100)
    // if we got here, then the desired year was below bounds, find the earliest plan we do have and use that
    // don't presume the csvdata are sorted, sort it here
    const earliestplan = allcsvdata.slice();
    earliestplan.sort((p, q) => { return p.year <= q.year ? -1 : 1; });  // oldest to recent, so 0 is earliest plan
    return earliestplan[0];
};

// called from updateStatsFromCsvContent() to encapsulate some logic for extracting the data relevant to this year
// Election is one specific election-data row for a specific year, and needs an exact match for CURRENT_VIEW.year or else it's a no-data condition
// in the case of Elections we may have no data for this year & boundary
window.getDataForThisYear_Election = (allcsvdata, desiredyear, options={}) => {
    const matchingrow = allcsvdata.filter((row) => { return row.year == desiredyear; })[0];
    return matchingrow;
};

window.updateMetricsTitle = (yeardata) => {
    const minyear = yeardata.plan_minyear;
    const maxyear = yeardata.plan_maxyear;
    const year    = yeardata.year;

    // compose a title for what we're seeing
    // single-year Plan
    // multi-year Plan
    // single-year Election details
    let title = `${minyear}-${maxyear} Redistricting Plan`;
    if (minyear == maxyear) {
        title = `${maxyear} Redistricting Plan`;  // don't say "2000-2000 plan"
    }
    if (CURRENT_VIEW.planorelection == 'election') {
        title = `${year} Election`;
    }

    // apply it
    $('#maincontent span[data-field="title"]').text(title);
};

window.updateMetricsSummary = (yeardata) => {
    // compose a sentence summarizing how many metrics indicate a skew one way or the other
    // e.g. "2 out of 3 metrics agree..." or "all metrics agree..."
    const eg_score  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const pb_score  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];
    const mm_score  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];

    // how many metrics favor D or R beyond threshold?
    const favor_party_eg = lookupBias('eg', eg_score, CURRENT_VIEW.boundtype);
    const favor_party_pb = lookupBias('pb', pb_score, CURRENT_VIEW.boundtype);
    const favor_party_mm = lookupBias('mm', mm_score, CURRENT_VIEW.boundtype);
    const metrics_favor_d = [ favor_party_eg, favor_party_pb, favor_party_mm ].filter((biasinfo) => { return biasinfo.isbiased && biasinfo.partycode == 'd'; }).length;
    const metrics_favor_r = [ favor_party_eg, favor_party_pb, favor_party_mm ].filter((biasinfo) => { return biasinfo.isbiased && biasinfo.partycode == 'r'; }).length;

    // compose a sentence on how biased this plan is according to how many metrics favor each party
    // with 2 out of 3 biases being worth calling out (and only if we have data for all 3)
    const howmanymetrics = [eg_score, pb_score, mm_score ].filter((score) => ! isNaN(score) ).length;
    const metriccountwords = {
        1: 'one metric',
        2: 'two metrics',
        3: 'three metrics',
    }[howmanymetrics];
    const biascountstatement  = `We used ${metriccountwords} to analyze this plan.`;

    let biasstatement = "The metrics do not consistently indicate a skew in either party’s favor.";
    switch (howmanymetrics) {
        case 3:
            if      (metrics_favor_d == 3) biasstatement = "All three metrics indicate a pro-Democrat skew.";
            else if (metrics_favor_r == 3) biasstatement = "All three metrics indicate a pro-Republican skew.";
            else if (metrics_favor_d == 2 && metrics_favor_r == 0) biasstatement = "Two of the three metrics indicate a pro-Democrat skew.";
            else if (metrics_favor_r == 2 && metrics_favor_d == 0) biasstatement = "Two of the three metrics indicate a pro-Republican skew.";
            break;
        case 2:
            if      (metrics_favor_d == 2) biasstatement = "Both metrics indicate a pro-Democrat skew.";
            else if (metrics_favor_r == 2) biasstatement = "Both metrics indicate a pro-Republican skew.";
            break;
        case 1:
            if      (metrics_favor_d == 1) biasstatement = "This one metric indicates a pro-Democrat skew.";
            else if (metrics_favor_r == 1) biasstatement = "This one metric indicates a pro-Republican skew.";
            else                           biasstatement = "This one metric does not indicate a skew in either party’s favor.";
            break;
    }

    // fill it in
    $('#maincontent span[data-metric="biasstatementconclusion"]').text(biasstatement);
    $('#maincontent span[data-metric="biasstatementhowmanymetrics"]').text(biascountstatement);
};

window.updateMetricsTabs = (yeardata) => {
    // fetch the seat counts, vote counts, bias metric scores, ... depending on whether we are showing a Plan or Election
    const eg_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const pb_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];
    const mm_score    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];
    const eg_rank     = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].egrank ];
    const bias_rank   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].biasrank ];
    const mmd_rank    = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mmrank ];
    const seats_rep   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats_rep ];
    const seats_dem   = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats_dem ];
    const totalseats  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].seats ];

    // for the selected year/plan
    // the 3 plan-bias metrics: do any of them show a bias toward D or R?
    // tag the biasicon icons in the metrics' tabs
    const biaseval_eg    = lookupBias('eg', eg_score, CURRENT_VIEW.boundtype);
    const favor_party_eg = biaseval_eg.party;
    const loser_party_eg = biaseval_eg.otherparty;
    const favor_code_eg  = biaseval_eg.partycode;
    const loser_code_eg  = biaseval_eg.otherparty;
    const favor_color_eg = biaseval_eg.colorcode;
    const cssclass_eg    = biaseval_eg.cssclass;
    const isbiased_eg    = biaseval_eg.isbiased;
    const hadseats       = favor_party_eg == 'Republican' ? seats_rep : seats_dem;
    const statement_eg   = `${! isbiased_eg ? 'This metric indicates a balanced plan.' : ''} Votes for ${favor_party_eg} candidates were inefficient at a rate ${(100 * Math.abs(eg_score)).toFixed(1)}% lower than votes for ${loser_party_eg} candidates.`;
    const biastext_eg    = `${! isbiased_eg ? 'No consistent skew was found in favor of either party.' : ''} This plan is more skewed than ${Math.round(100 * eg_rank)}% of the enacted plans we have analyzed nationwide.`;
    const roundscore_eg  = Math.round(100 * Math.abs(eg_score));  // per https://github.com/PlanScore/PlanScore/issues/170 these ignore the usual balanced-threshold; we want to show even 1% but keep a balanced color

    const biaseval_pb    = lookupBias('pb', pb_score, CURRENT_VIEW.boundtype);
    const favor_party_pb = biaseval_pb.party;
    const favor_color_pb = biaseval_pb.color;
    const favor_code_pb  = biaseval_pb.partycode;
    const loser_code_pb  = biaseval_pb.otherparty;
    const cssclass_pb    = biaseval_pb.cssclass;
    const isbiased_pb    = biaseval_pb.isbiased;
    const statement_pb   = `${! isbiased_pb ? 'This metric indicates a balanced plan.' : ''} ${favor_party_pb}s would win ${(100 * Math.abs(pb_score)).toFixed(1)}% extra seats in a hypothetical, perfectly tied election.`;
    const biastext_pb    = `${! isbiased_pb ? 'No consistent skew was found in favor of either party.' : ''} This plan is more skewed than ${Math.round(100 * bias_rank)}% of the enacted plans we have analyzed nationwide.`;
    const roundscore_pb  = Math.round(100 * Math.abs(pb_score));  // per https://github.com/PlanScore/PlanScore/issues/170 these ignore the usual balanced-threshold; we want to show even 1% but keep a balanced color
    const biaseval_mm    = lookupBias('mm', mm_score, CURRENT_VIEW.boundtype);
    const favor_party_mm = biaseval_mm.party;
    const favor_color_mm = biaseval_mm.color;
    const favor_code_mm  = biaseval_mm.partycode;
    const loser_code_mm  = biaseval_mm.otherparty;
    const cssclass_mm    = biaseval_mm.cssclass;
    const isbiased_mm    = biaseval_mm.isbiased;
    const statement_mm   = `${! isbiased_mm ? 'This metric indicates a balanced plan.' : ''} The median ${favor_party_mm} vote share was ${(100 * Math.abs(mm_score)).toFixed(1)}% higher than the mean ${favor_party_mm} vote share.`;
    const biastext_mm    = `${! isbiased_mm ? 'No consistent skew was found in favor of either party.' : ''} This plan is more skewed than ${Math.round(100 * mmd_rank)}% of the enacted plans we have analyzed nationwide.`;
    const roundscore_mm  = Math.round(100 * Math.abs(mm_score));  // per https://github.com/PlanScore/PlanScore/issues/170 these ignore the usual balanced-threshold; we want to show even 1% but keep a balanced color

    // color the tab-swatches for the three metrics
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-efficiencygap"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democratic').text(' ');
        if (isbiased_eg) $swatch.addClass(cssclass_eg).text(favor_code_eg);
    }
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-partisanbias"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democratic').text(' ');
        if (isbiased_pb) $swatch.addClass(cssclass_pb).text(favor_code_pb);
    }
    {
        let $swatch = $('#maincontent ul.nav-tabs a[href="#tab-meanmedian"] span.biasicon');
        $swatch.removeClass('republican').removeClass('democratic').text(' ');
        if (isbiased_mm) $swatch.addClass(cssclass_mm).text(favor_code_mm);
    }

    // show/hide the data-have-metric content, depending on whether we have each of the 3 metrics
    // some state & year & district have only 1 or 2 of the 3 metrics
    // the rest of the processing below, still works through even if we have a null/NaN for the values, they look bad but since we're hiding them...
    {
        if (isNaN(eg_score)) {
            const nodatatext = `We did not calculate Efficiency Gap for ${SELECTED_STATE}’s ${CURRENT_VIEW.year} Redistricting Plan`;
            $('#tab-efficiencygap span[data-have-metric="true"]').hide();
            $('#tab-efficiencygap span[data-have-metric="false"]').show().find('h2').text(nodatatext);
        }
        else {
            $('#tab-efficiencygap span[data-have-metric="true"]').show();
            $('#tab-efficiencygap span[data-have-metric="false"]').hide();
        }

        if (isNaN(pb_score)) {
            const nodatatext = `We did not calculate Partisan Bias for ${SELECTED_STATE}’s ${CURRENT_VIEW.year} Redistricting Plan`;
            $('#tab-partisanbias span[data-have-metric="true"]').hide();
            $('#tab-partisanbias span[data-have-metric="false"]').show().find('h2').text(nodatatext);
        }
        else {
            $('#tab-partisanbias span[data-have-metric="true"]').show();
            $('#tab-partisanbias span[data-have-metric="false"]').hide();
        }

        if (isNaN(mm_score)) {
            const nodatatext = `We did not calculate Mean-Median for ${SELECTED_STATE}’s ${CURRENT_VIEW.year} Redistricting Plan`;
            $('#tab-meanmedian span[data-have-metric="true"]').hide();
            $('#tab-meanmedian span[data-have-metric="false"]').show().find('h2').text(nodatatext);
        }
        else {
            $('#tab-meanmedian span[data-have-metric="true"]').show();
            $('#tab-meanmedian span[data-have-metric="false"]').hide();
        }
    }

    // fill in those +DR% numbers and the summary texts, at the top of the metric tabs
    {
        let metricdrsum_eg   = '0% Balanced';
        if (roundscore_eg) metricdrsum_eg = `+${roundscore_eg}% ${favor_party_eg}`;

        $('#tab-efficiencygap span[data-field="metricdrsum"]').text(metricdrsum_eg);
        $('#tab-efficiencygap span[data-field="metricstatement"]').text(statement_eg);
        $('#tab-efficiencygap span[data-field="plancompare"]').text('This plan is more skewed toward X than 100% all of the enacted plans we have analyzed nationwide.');
        $('#tab-efficiencygap span[data-field="biasstatement"]').text(biastext_eg);
    }
    {
        let metricdrsum_pb   = '0% Balanced';
        if (roundscore_pb) metricdrsum_pb = `+${roundscore_pb}% ${favor_party_pb}`;

        $('#tab-partisanbias span[data-field="metricdrsum"]').text(metricdrsum_pb);
        $('#tab-partisanbias span[data-field="metricstatement"]').text(statement_pb);
        $('#tab-partisanbias span[data-field="plancompare"]').text('This plan is more skewed toward X than 100% all of the enacted plans we have analyzed nationwide.');
        $('#tab-partisanbias span[data-field="biasstatement"]').text(biastext_pb);
    }
    {
        let metricdrsum_mm   = '0% Balanced';
        if (roundscore_mm) metricdrsum_mm = `+${roundscore_mm}% ${favor_party_mm}`;

        $('#tab-meanmedian span[data-field="metricdrsum"]').text(metricdrsum_mm);
        $('#tab-meanmedian span[data-field="metricstatement"]').text(statement_mm);
        $('#tab-meanmedian span[data-field="plancompare"]').text('This plan is more skewed toward X than 100% all of the enacted plans we have analyzed nationwide.');
        $('#tab-meanmedian span[data-field="biasstatement"]').text(biastext_mm);
    }

    // color those +DR% boxes
    {
        const $sumbox = $('#tab-efficiencygap div.metricdrsum').removeClass('republican').removeClass('democratic').removeClass('balanced').addClass(cssclass_eg);
    }
    {
        const $sumbox = $('#tab-partisanbias div.metricdrsum').removeClass('republican').removeClass('democratic').removeClass('balanced').addClass(cssclass_pb);
    }
    {
        const $sumbox = $('#tab-meanmedian div.metricdrsum').removeClass('republican').removeClass('democratic').removeClass('balanced').addClass(cssclass_mm);
    }
};

window.updateSeatShareChart = (yeardata) => {
    const pb_score = 100 * yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];

    let r_seatshare = 50;
    let d_seatshare = 50;

    if (pb_score < 0) {  // as usual, R is <0
        r_seatshare += Math.abs(pb_score);
        d_seatshare -= Math.abs(pb_score);
    }
    else if (pb_score > 0) {
        r_seatshare -= Math.abs(pb_score);
        d_seatshare += Math.abs(pb_score);
    }

    // construct the chart series
    const votechartdata = [
        {
            name: 'Seat Share',
            data: [ d_seatshare, r_seatshare ],
            colors: [ WASTEDVOTE_CHART_WASTED_D, WASTEDVOTE_CHART_WASTED_R ],
        }
    ];

    // now chart it
    // and show the chart, in case it was previously hidden
    $('#chart-pbseatshare').show();
    Highcharts.chart('chart-pbseatshare', {
        chart: {
            type: 'bar',
        },
        credits: {
            enabled: false,
        },
        title: {
            text: 'Seat Share at 50% of the Vote',
            margin: 0,
        },
        xAxis: {
            categories: ['D', 'R']
        },
        yAxis: {
            min: 0,
            max: 100,
            title: {
                enabled: false,
            },
        },
        legend: {
            enabled: false,
        },
        tooltip: {
            formatter: function () {
                const party = this.point.category == 'D' ? 'Democratic' : 'Republican';
                return `${party}<br/>${this.y.toLocaleString()}% ${this.series.name}`;
            },
        },
        plotOptions: {
            series: {
                stacking: 'normal',
                pointPadding: 0,
                groupPadding: 0,
                pointWidth: 25,
                colorByPoint: true,  // use the custom-assigned colors,
                animation: false,
            }
        },
        series: votechartdata,
    });
};

window.updateWastedVotesChart = (yeardata) => {
    // fetch the vote tallies for this election/plan
    const totalvotes = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_both ];
    const wasted_dem = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].wasted_dem ];
    const wasted_rep = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].wasted_rep ];
    const votes_dem  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_dem ];
    const votes_rep  = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].votes_rep ];

    // if there is no data on votes + wasted votes for this election/plan
    // then just hide this chart
    if (! totalvotes) {
        $('#chart-egvoteswasted').hide();
        return;
    }

    // construct the chart series
    const votechartdata = [
        {
            name: 'Inefficient Votes',
            data: [0, 0],
            colors: [ WASTEDVOTE_CHART_WASTED_D, WASTEDVOTE_CHART_WASTED_R ],
        },
        {
            name: 'Efficient Votes',
            data: [0, 0],
            colors: [ WASTEDVOTE_CHART_USEFUL_D, WASTEDVOTE_CHART_USEFUL_R ],
        }
    ];
    votechartdata[0].data[0] = wasted_dem;
    votechartdata[0].data[1] = wasted_rep;
    votechartdata[1].data[0] = votes_dem - wasted_dem;
    votechartdata[1].data[1] = votes_rep - wasted_rep;

    // now chart it
    // and show the chart, in case it was previously hidden
    $('#chart-egvoteswasted').show();
    Highcharts.chart('chart-egvoteswasted', {
        chart: {
            type: 'bar',
        },
        credits: {
            enabled: false,
        },
        title: {
            text: 'Efficient Votes and Inefficient Votes',
            margin:0,
        },
        xAxis: {
            categories: ['D', 'R']
        },
        yAxis: {
            min: 0,
            title: {
                enabled: false,
            },
            tickAmount: 4,
            showFirstLabel: false,
        },
        legend: {
            enabled: false,
        },
        tooltip: {
            formatter: function () {
                const party = this.point.category == 'D' ? 'Democratic' : 'Republican';
                return `${party}<br/>${this.y.toLocaleString()} ${this.series.name}`;
            },
        },
        plotOptions: {
            series: {
                stacking: 'normal',
                pointPadding: 0,
                groupPadding: 0,
                pointWidth: 25,
                colorByPoint: true,  // use the custom-assigned colors,
                animation: false,
            }
        },
        series: votechartdata,
    });
};

window.redrawYearPickers = (csvdata, selectedyeardata={}) => {
    // see initYearPickers() for the delegated event handlers and further explanation
    // per https://github.com/PlanScore/PlanScore/issues/217, the mobile & desktop yearpickers must be redrawn based on the years represented in the CSV
    // for the given district type & state, since it turns out election years aren't consistent between states, nor between a state's district levels
    // e.g. KY statehouse, ushouse, and statesenate are not the same, and are all a mix of even and odd years
    // per https://github.com/PlanScore/PlanScore/issues/241 the data we're showing may not be for CURRENT_VIEW.year at all, as we try to show SOMETHING especially in Plan mode
    // so highlighting the current election/plan can be a bit complicated

    // there are two separate UIs: the mobile one with "< year >" and a prev/next behavior
    // and the desktop one forming a set of beads down the side (with colors indicating EG bias that year)

    // note too that we still support showing Plan data or Election-year data
    // even though the display of Election-level data is presently disabled (https://github.com/PlanScore/PlanScore/issues/94) until they want it back again

    // mobile picker - election
    // disabled per https://github.com/PlanScore/PlanScore/issues/94 but likely to come back, so we have to keep it working even though nobody knows it exists
    // empty the links and draw new ones
    // show the current year (hiding years not the current one)
    // show/hide the prev/next links if this is the first/last year
    {
        // make a list of years found in the data
        const available_years = [];
        csvdata.forEach((row) => {
            available_years.push(parseInt(row.year));
        });
        available_years.sort();

        // update the UI: empty the current set of links, draw new ones in a hidden state, then show the one that matches the displayed data
        const $yearpicker  = $('#yearpicker-small > div[data-picker="election"]');
        const $prevbutton  = $yearpicker.find('div.nextprev.left');
        const $nextbutton  = $yearpicker.find('div.nextprev.right');

        const $readout = $yearpicker.find('div.readout').empty();
        available_years.forEach((year) => {
            const $thislink = $(`<span data-year="${year}">${year} Election</span>`).appendTo($readout).hide();
        });

        const $thislink = $readout.find('> span').filter(`[data-year="${selectedyeardata.year ? selectedyeardata.year : CURRENT_VIEW.year}"]`).show();  // unlike Plans, Elections are always for one specific year

        // update the UI: disable the next/prev links if this is the last/first year
        if ($thislink.is(':first-child')) $prevbutton.addClass('disabled');
        else                              $prevbutton.removeClass('disabled');
        if ($thislink.is(':last-child'))  $nextbutton.addClass('disabled');
        else                              $nextbutton.removeClass('disabled');
    }

    // mobile picker - plan
    // get the list of plans and their active years
    // empty the links and draw new ones for the existing plans
    // show the current year (hiding years not the current one)
    // show/hide the prev/next links if this is the first/last year
    {
        // make a list of plans found in the data
        const plans_known = {};
        csvdata.forEach((row) => {
            if (! plans_known[row.plan]) {
                plans_known[row.plan] = { plan: row.plan, minyear: row.plan_minyear, maxyear: row.plan_maxyear };
            }
        });
        const plans_listing = Object.values(plans_known);
        plans_listing.sort((p,q) => { return p.minyear < q.minyear ? -1 : 1; });

        // update the UI: empty the current set of links, draw new ones in a hidden state, then show the one that matches the displayed data
        const $yearpicker  = $('#yearpicker-small > div[data-picker="plan"]');
        const $prevbutton  = $yearpicker.find('div.nextprev.left');
        const $nextbutton  = $yearpicker.find('div.nextprev.right');

        const $readout = $yearpicker.find('div.readout').empty();
        plans_listing.forEach((planinfo) => {
            const text = planinfo.minyear == planinfo.maxyear ? `${planinfo.minyear} Plan` : `${planinfo.minyear}-${planinfo.maxyear} Plan`;
            const $thislink = $(`<span data-plan="${planinfo.plan}" data-year="${planinfo.minyear}" data-minyear="${planinfo.minyear}" data-maxyear="${planinfo.maxyear}">${text}</span>`).appendTo($readout).hide();
        });

        const $thislink = selectedyeardata.plan ? $readout.find('> span').filter(`[data-plan="${selectedyeardata.plan}"]`) : $readout.find('> span').filter(`[data-year="${CURRENT_VIEW.year}"]`);
        $thislink.show();

        // update the UI: disable the next/prev links if this is the last/first year
        if ($thislink.is(':first-child')) $prevbutton.addClass('disabled');
        else                              $prevbutton.removeClass('disabled');
        if ($thislink.is(':last-child'))  $nextbutton.addClass('disabled');
        else                              $nextbutton.removeClass('disabled');
    }

    // desktop picker
    // lists years on the right, and draws plan-start circles on the left
    // try to smooth out "lumpy" distributions by adding null years where we find larger gaps (https://github.com/PlanScore/PlanScore/issues/217)
    {
        // a straight list: all available years
        // a lookup dict: year => plan (to tag a each year's link with its plan for display)
        // a lookup dict: for each plan, its first year (to add the plan-start dots)
        // a lookup dict: year => EG bias ratings (used for plan-start dots)
        const available_years = [];
        const yearplans = {};
        const planfirstyears = {};
        const yearbiasinfo = {};
        csvdata.forEach((row) => {
            yearplans[row.year] = row.plan;
            planfirstyears[row.plan] = row.plan_minyear;
            yearbiasinfo[row.year] = lookupBias('eg', row.eg_adj_avg, CURRENT_VIEW.boundtype);
            available_years.push(parseInt(row.year));
        });
        available_years.sort();

        // for the year we are currently showing, what plan would be active?
        // we'll use this to highlight the currently-active plan, once we have the UI laid out
        const currentplan = selectedyeardata.plan ? selectedyeardata.plan : yearplans[CURRENT_VIEW.year];

        // pad the years list with null-years, where we find a gap larger than 2 years
        // this allows the timeline to be stretched with empty rows, so we show gaps in coverage
        // not all states have 2-year cycles for all district types, so we hardcode these hacks to handle that chaos
        let yearsbetweencycles = 2;
        if (SELECTED_STATE == 'Alabama' && CURRENT_VIEW.boundtype == 'statehouse') yearsbetweencycles = 4;
        if (SELECTED_STATE == 'Mississippi' && CURRENT_VIEW.boundtype == 'statehouse') yearsbetweencycles = 4;

        const nullpadded_years = [];
        for (var i=0, l=available_years.length; i+1<l; i++) {  // all except the last
            var thisyear = available_years[i];
            var nextyear = available_years[i+1];

            for (let y=thisyear; y<nextyear; y+=yearsbetweencycles) {
                nullpadded_years.push(y);
            }
        }
        nullpadded_years.push(available_years[available_years.length-1]);  // don't forget the very last year
        nullpadded_years.sort();

        // reverse the years list: most recent at the top
        nullpadded_years.reverse();

        // purge the existing links (and re-add the titles)
        // then draw new ones one row at a time
        // a row is an illusion: there is a plan-begin/plan-continue indicator on the left, and the year on the right
        const $plansdiv = $('#yearpicker-big div.plans').empty().append('<span>Enacted<br>Plans</span>');
        const $yearsdiv = $('#yearpicker-big div.elections').empty().append('<span>Election<br>Years</span>');

        nullpadded_years.forEach((year) => {
            const plan          = yearplans[year];
            const planfirstyear = planfirstyears[plan];
            const biasinfo      = yearbiasinfo[year];

            // if this is a null year (no plan), it's really just a spacer with a plan-continue marker: no year, no click behaviors, etc.
            // if it has a plan, it gets the year readout and all
            if (plan) {
                const $planlink = $(`<a data-plan="${plan}" data-year="${year}" title="Show details for this districting plan"><span></span></a>`).addClass('plan-continue').appendTo($plansdiv);
                const $yearlink = $(`<a data-plan="${plan}" data-year="${year}" title="Show details for the ${year} election year"><span class="swatch"></span><span class="year">${year}</span></a>`).appendTo($yearsdiv);

                // if this year is the starting year of a plan, change it from a continue-line to a start-circle with a color indicating its bias
                if (year == planfirstyear) {
                    $planlink.removeClass('plan-continue').addClass('plan-begin');
                    $planlink.find('span').css({ 'background-color': biasinfo.color });
                }

                // if we are currently showing Plans (as opposed to elections) and this year's plan is that, then additional highlighting
                if (CURRENT_VIEW.planorelection == 'plan' && plan == currentplan) {
                    $planlink.addClass('active');
                }
                else if (CURRENT_VIEW.planorelection == 'election' && selectedyeardata.year == year) {
                    $yearlink.addClass('active');
                }
            }
            else {
                // the null years links, don't really do nothing as discussed
                // they must be tagged with data-plan so as to be highlighted along with other plan years
                // and need a data-year (of a real year with data) so they can be clicked to show that year's data
                // note: if we ever reinstate showing Election info, this fudging to show the year of the nearest plan is likely to backfire, and may need to be removed
                let latestplanyearbeforethis = available_years.filter((fyear) => { return fyear < year; });
                latestplanyearbeforethis = latestplanyearbeforethis[latestplanyearbeforethis.length - 1];
                const priorplan = yearplans[latestplanyearbeforethis];

                const $planlink = $(`<a data-plan="${priorplan}" data-year="${latestplanyearbeforethis}"><span></span></a>`).addClass('plan-continue').appendTo($plansdiv);
                const $yearlink = $(`<a data-plan="${priorplan}" data-year="${latestplanyearbeforethis}"></a>`).appendTo($yearsdiv);

                // if we are currently showing Plans (as opposed to elections) and this year's plan is that, then additional highlighting
                if (CURRENT_VIEW.planorelection == 'plan' && priorplan == currentplan) {
                    $planlink.addClass('active');
                }
            }
        });
    }
};

window.drawBiasBellCharts = (yeardata) => {
    // just a wrapper around drawBiasBellChart as it's mostly identical for all 3 metrics
    const egscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].eg ];
    const mmscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].mm ];
    const pbscore = yeardata[ ELECTION_PLAN_RECORD_FIELDS[CURRENT_VIEW.planorelection].bias ];

    drawBiasBellChart('eg', egscore, 'metric-bellchart-eg', CURRENT_VIEW.boundtype, CURRENT_VIEW.planorelection);
    drawBiasBellChart('mm', mmscore, 'metric-bellchart-mm', CURRENT_VIEW.boundtype, CURRENT_VIEW.planorelection);
    drawBiasBellChart('pb', pbscore, 'metric-bellchart-pb', CURRENT_VIEW.boundtype, CURRENT_VIEW.planorelection);
};

window.updateMapForCurrentSelection = (yeardata) => {
    const whichplan      = yeardata.plan;
    const whichlevel     = CURRENT_VIEW.boundtype;
    const whichyear      = CURRENT_VIEW.year;
    const planorelection = CURRENT_VIEW.planorelection;
    const geojsonurl     = `/data/districtpolygons/${whichlevel}-${whichplan}.json`;
    const csvurl         = `/data/electionoutcomes_${whichlevel}.csv`;
    const statecode      = yeardata.state;
    // console.log([ 'updateMapForCurrentSelection', yeardata, CURRENT_VIEW.year, CURRENT_VIEW.boundtype, whichplan ]);

    // load the TopoJSON and set it up as the MAP's polygons layer
    // keep a reference to the layer so we can add/remove it
    $.get(geojsonurl, function (jsondata) {
        $('#map').show();
        MAP.invalidateSize();

        if (MAP.polygondistrictsoverlay) {
            MAP.removeLayer(MAP.polygondistrictsoverlay);
        }

        MAP.polygondistrictsoverlay = new L.TopoJSON(jsondata, {
            style: MAP_DISTRICT_STYLE_DEFAULT,
        }).addTo(MAP);

        applyStylesToMapPolygons();
    }, 'json')
    .fail(function (error) {
        // on error, hide map: we have no geometry for this plan
        $('#map').hide();
    });

    // after loading the polygons, style them by election winner or plan winner
    // that data is in a CSV of all election+plan outcomes, we will filter to state
    // then style polygons by the relevant field
    function applyStylesToMapPolygons() {
        Papa.parse(csvurl, {
            download: true,
            header: true,
            complete: function (results) {
                // filter to year + state, or year + plan
                // filtering down the data in a separate step, makes it a lot easier to isolate the relevant results, separately from the polygon-style code later
                if (planorelection == 'election') {
                    // election year; filter by "year" and the "plan" field starting with this state code
                    results = results.data.filter((row) => {
                        return row.year == whichyear && row.plan.substr(0, 2) == statecode;
                    });
                }
                else {
                    // must be a plan; filter by the "plan" field
                    results = results.data.filter((row) => {
                        return row.plan == whichplan;
                    });
                }
                // console.log([ 'applyStylesToMapPolygons() results are:', results ]);

                // go through the polygons and match their "DISTRICT" property to CSV's "district" field
                // then style them according to winner of that election or plan
                MAP.polygondistrictsoverlay.eachLayer(function (layer) {
                    const district_id = layer.feature.properties.DISTRICT;
                    const csvinfo = results.filter((row) => { return row.district == district_id; })[0];

                    if (! csvinfo) {
                        // this district on the map, has no corresponding entry in the election/plan data
                        layer.setStyle(MAP_DISTRICT_STYLE_DEFAULT);
                    }
                    else if (planorelection == 'election') {
                        // color by election winner
                        switch (csvinfo.winner) {
                            case 'D':
                                layer.setStyle(MAP_DISTRICT_STYLE_DEMOCRAT);
                                break;
                            case 'R':
                                layer.setStyle(MAP_DISTRICT_STYLE_REPUBLICAN);
                                break;
                            default:
                                layer.setStyle(MAP_DISTRICT_STYLE_MIXED);
                                break;
                        }
                    }
                    else {
                        // color by plan winner
                        switch (csvinfo.winner_plan) {
                            case 'D':
                                layer.setStyle(MAP_DISTRICT_STYLE_DEMOCRAT);
                                break;
                            case 'R':
                                layer.setStyle(MAP_DISTRICT_STYLE_REPUBLICAN);
                                break;
                            default:
                                layer.setStyle(MAP_DISTRICT_STYLE_MIXED);
                                break;
                        }
                    }
                });
            }, // end of CSV download
            error: function () {
                // an error, meaning bad network or missing CSV
                // set all polygons to the nodata style
                MAP.polygondistrictsoverlay.eachLayer(function (layer) {
                    layer.setStyle(MAP_DISTRICT_STYLE_DEFAULT);
                });
            },
        });
    }
};

window.logMetricToggleToGoogleAnalytics = (whichmetric) => {
    if (! gtag) return;  // no Google Tag Manager = don't bother; this should be declared along with GTM

    gtag('event', 'metricdetails', {
        value: CURRENT_VIEW.year,
        event_category: whichmetric,
        event_label : `${CURRENT_VIEW.boundtype}-${CURRENT_VIEW.planorelection}`,
    });
};
