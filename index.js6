// this page's HTML template with the [hash] cache-buster
// and the only stylesheet
require('./index.scss');
require('./index.src.html');

// shared constants between pages: the list of years, the red-blue color gradient, ...
import { PLAN_YEARS } from "./_common/constants";
import { STATE_CODE_TO_NAME } from "./_common/constants";
import { BELLCURVE_SPREAD } from "./_common/constants";
import { lookupBias, twoDigits } from "./_common/functions";

// bundle polyfills and local/vendor libraries specific to this page
//require('./js/leaflet-control-basemapbar.js');
//require('./js/leaflet-control-basemapbar.css');

//
// CONSTANTS
//

// the currently-visible state: boundary type + year, e.g. US House districts for 1984
// these are affected by window.selectXXX() family of functions which ultimately are all wrappers over loadDataForSelectedBoundaryAndYear()
const CURRENT_VIEW = {};

// track whether this is the first render, so we can suppress transitions on initial load
let firstRender = true;

// year picker timeline animation; see yearAnimationToggle()
const ANIMATION = {
    delayseconds: 0.75,  // time delay (in seconds) between switches
    timer: undefined,  // if playing, an interval handle from setInterval(); else undefined
};

// prediction slider state; see initPredictionSlider()
const PREDICTION_SLIDER = {
    isDragging: false,
    initialized: false,
    minX: null,      // set during initialization from DOM
    maxX: null,      // set during initialization from DOM
    centerY: null,   // set during initialization from DOM
    minValue: -12,   // R+12 (right side)
    maxValue: 12,    // D+12 (left side)
    currentValue: 0, // default: Even (center)
};

// the map uses a choropleth constructed from BELLCURVE_SPREAD
// but for nodata states, use this NODATA value and this color fill
const MAP_NODATA_VALUE = 999999;
const MAP_NODATA_FILLCOLOR = '#ffffff';
const MAP_NODATA_LABELCOLOR = '#cccccc';
const MAP_BORDER_COLOR = '#6E6E6E';
const MAP_TRANSPARENT = 'rgba(0, 0, 0, 0)';

// the color of the state labels on the map
const MAP_LABELSIZE = '9px';
const MAP_LABELCOLOR = 'black';

// style for mouseover-ing the states on the map
const MAP_MOUSEOVER_COLOR = '#333333';
const MAP_MOUSEOVER_WIDTH = 2;

// the Esc key
const KEYCODE_ESC = 27;

// Minimum seats required for clickable states in U.S. House view
const MINIMUM_USHOUSE_SEATS = 7;

// Regular expression for "matrix(scaleX, _, _, _, translateX, translateY)"
const MATRIX_PAT = /matrix\(([^)]+), [^)]+, [^)]+, [^)]+, ([^)]+), ([^)]+)\)/


//
// PAGE STARTUP / INIT FUNCTIONS
//

$(document).ready(function () {
    // Suppress transitions for the initial render
    $('.state-shape').addClass('suppress-transition');
    $('.offshore-box').addClass('suppress-transition');
    $('.state-label').addClass('suppress-transition');
    $('.state-underline').addClass('suppress-transition');

    initYearPickers();
    initBoundaryPicker();
    initStatePopup();
    initTabMetricsTracking();
    initLoadStartingConditions();  // this will implicitly call loadDataForSelectedBoundaryAndYear() after setup, loading the map

    $(window).on('resize', handleResize);
    handleResize();
});

window.initTabMetricsTracking = () => {
    // when they switch metrics tabs, log a Google Analytics event
    $('#tabs-metrics a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
        const whichtab = $(e.target).prop('href').replace(/.+#tab-/, '');  // the suffix is the metric name, e.g. #tab-efficiencygap
        logToGoogleAnalytics('metricread', whichtab);
    });
};

window.initStatePopup = () => {
    // the stateinfo popup is managed by selectState()
    // but we do want to add some event handlers

    // the popup's X button closes it
    $('#stateinfo-popup button').click(function () {
        selectState('');
    });

    // a keypress of the Esc key at any time, will close it
    $(window).on('keyup', function (event) {
        if (event.keyCode == KEYCODE_ESC) {
            selectState('');
        }
    });

    // a click anywhere on the page will close it (except within the popup, on the map, on a yearpicker, ...)
    $('#stateinfo-popup').click(function (event) {
        event.stopPropagation();
    });
    $('#yearpicker-big').click(function (event) {  // the yearpicker timeline AND the play/pause button
        event.stopPropagation();
    });
    $('#yearpicker-small').click(function (event) {
        event.stopPropagation();
    });
    $('#boundarypicker').click(function (event) {
        event.stopPropagation();
    });
    $('#map').on('click', 'g', function (event) {  // only the visible map, within the whole #map
        event.stopPropagation();
    });
    $('html').click(function () {
        selectState('');
    });

    // selecting the state that is already selected, will also select nothing
    // that's actually done within selectState()
};

window.initYearPickers = () => {
    // there are 2 year pickers: mobile and desktop
    // desktop is a fancy series of HTML/CSS dots which can be clicked to select a year
    // mobile is a prev/next thing to cycle years with arrows
    // both of these connect to selectYear()

    const $picker_small = $('#yearpicker-small');
    const $year_listing = $picker_small.find('div.readout');
    PLAN_YEARS.forEach((year) => {
        $(`<span data-year="${year}">${year == 2026 ? '2024+Remaps<sup>*</sup>' : year}</span>`).appendTo($year_listing).hide();
    });

    $picker_small.on('click', 'div.nextprev.right', function () {
        const $targetbutton = $year_listing.find('span:visible').next('span');
        const year = $targetbutton.attr('data-year');
        if (! year) return;  // don't allow clicking past the first/last
        selectYear(year);
        logToGoogleAnalytics('yearselected', year);
    });
    $picker_small.on('click', 'div.nextprev.left', function () {
        const $targetbutton = $year_listing.find('span:visible').prev('span');
        const year = $targetbutton.attr('data-year');
        if (! year) return;  // don't allow clicking past the first/last
        selectYear(year);
        logToGoogleAnalytics('yearselected', year);
    });

    // yearpicker-big: add click handlers for year selection
    const $picker_big = $('#yearpicker-big');
    // attach to all year elements in both timeline and future
    $('#yearpicker-timeline a[id^="yearpicker-"], #yearpicker-future a[id^="yearpicker-"]', $picker_big).on('click', function () {
        const elementId = $(this).attr('id');
        let year = elementId.replace('yearpicker-', '');

        // When clicking on predict, use the current slider value to determine the year
        if (year === 'predict') {
            year = getPredictionYearString(PREDICTION_SLIDER.currentValue);
        }

        selectYear(year);
        logToGoogleAnalytics('yearselected', year);
    });

    // yearpicker-big: add click handler for play button
    $('#yearpicker-playbutton a', $picker_big).click(function () {
        yearAnimationToggle();
    });
};

window.initPredictionSlider = () => {
    // lazy initialization: only set up once when predict mode is first activated
    if (PREDICTION_SLIDER.initialized) return;
    PREDICTION_SLIDER.initialized = true;

    const $thumb = $('#yearpicker-predict-thumb');
    const $circle = $thumb.find('circle');
    const $label = $thumb.find('text');
    const $slider = $('#yearpicker-predict-slider');

    // read slider dimensions from DOM
    const sliderX = parseFloat($slider.attr('x'));
    const sliderWidth = parseFloat($slider.attr('width'));
    const sliderY = parseFloat($slider.attr('y'));
    const sliderHeight = parseFloat($slider.attr('height'));
    const circleRadius = parseFloat($circle.attr('r'));

    // calculate bounds with 1px clearance for circle
    PREDICTION_SLIDER.minX = sliderX + circleRadius + 1;
    PREDICTION_SLIDER.maxX = sliderX + sliderWidth - circleRadius - 1;
    PREDICTION_SLIDER.centerY = sliderY + (sliderHeight / 2);

    // original position of thumb in SVG (read from group's transform)
    const transformAttr = $thumb.attr('transform');
    const transformMatch = transformAttr ? transformAttr.match(/translate\(([^,]+)/) : null;
    const originalX = transformMatch ? parseFloat(transformMatch[1]) : 0;
    const originalY = parseFloat($circle.attr('cy'));

    // helper: convert slider position (x coordinate) to prediction value
    // reversed: left = D (positive), right = R (negative)
    const positionToValue = (x) => {
        const fraction = (x - PREDICTION_SLIDER.minX) / (PREDICTION_SLIDER.maxX - PREDICTION_SLIDER.minX);
        return Math.round(PREDICTION_SLIDER.maxValue - fraction * (PREDICTION_SLIDER.maxValue - PREDICTION_SLIDER.minValue));
    };

    // helper: convert prediction value to slider position (x coordinate)
    // reversed: left = D (positive), right = R (negative)
    const valueToPosition = (value) => {
        const fraction = (PREDICTION_SLIDER.maxValue - value) / (PREDICTION_SLIDER.maxValue - PREDICTION_SLIDER.minValue);
        return PREDICTION_SLIDER.minX + fraction * (PREDICTION_SLIDER.maxX - PREDICTION_SLIDER.minX);
    };

    // helper: format value as label text
    const formatLabel = (value) => {
        if (value === 0) return 'Even';
        return value > 0 ? `D+${value}` : `R+${Math.abs(value)}`;
    };

    // helper: update thumb position and label using matrix transform
    const updateThumb = (x, skipYearUpdate = false) => {
        // constrain x to slider bounds
        const constrainedX = Math.max(PREDICTION_SLIDER.minX, Math.min(PREDICTION_SLIDER.maxX, x));
        const value = positionToValue(constrainedX);

        PREDICTION_SLIDER.currentValue = value;

        // x is the desired absolute position, use it directly as translation
        // (since circle is at cx="0" in the group, translation = absolute position)
        const translateX = constrainedX;

        // apply matrix transform to move entire group
        $thumb.attr('transform', `translate(${translateX}, 0)`);

        // update label text
        $label.text(formatLabel(value));

        // update the year state to match slider position
        if (!skipYearUpdate) {
            const predictionYear = getPredictionYearString(value);
            // Only update the year and hash, don't reload data or trigger full selectYear
            if (CURRENT_VIEW.year !== predictionYear) {
                CURRENT_VIEW.year = predictionYear;
                updateAddressHash();
            }
        }
    };

    // prevent thumb click from triggering parent link
    $thumb.on('click', function (event) {
        event.preventDefault();
        event.stopPropagation();
    });

    // mousedown on thumb: start dragging
    $thumb.on('mousedown', function (event) {
        event.preventDefault();
        event.stopPropagation();
        PREDICTION_SLIDER.isDragging = true;
        $thumb.css('cursor', 'grabbing');
    });

    // mousemove on document: update position if dragging
    $(document).on('mousemove.predictionslider', function (event) {
        if (!PREDICTION_SLIDER.isDragging) return;

        // get mouse position relative to the SVG
        const svg = $('#yearpicker-future')[0];
        const pt = svg.createSVGPoint();
        pt.x = event.clientX;
        pt.y = event.clientY;
        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

        updateThumb(svgP.x);
    });

    // mouseup on document: stop dragging
    $(document).on('mouseup.predictionslider', function () {
        if (PREDICTION_SLIDER.isDragging) {
            PREDICTION_SLIDER.isDragging = false;
            $thumb.css('cursor', 'pointer');
        }
    });

    // initialize thumb to current value
    const initialPosition = valueToPosition(PREDICTION_SLIDER.currentValue);
    updateThumb(initialPosition, true);

    // After initialization, update the year state to match the slider position
    // This ensures CURRENT_VIEW.year and the hash are correct
    const predictionYear = getPredictionYearString(PREDICTION_SLIDER.currentValue);
    if (CURRENT_VIEW.year !== predictionYear) {
        CURRENT_VIEW.year = predictionYear;
        updateAddressHash();
    }
};

window.initBoundaryPicker = () => {
    $('#boundarypicker div[data-boundary]').click(function () {
        const boundarytype = $(this).attr('data-boundary');
        selectBoundaryType(boundarytype);
        logToGoogleAnalytics('boundarytype', boundarytype);
    });
};

window.initLoadStartingConditions = () => {
    // analyze the #year-polytype hash to see what year + type we should load
    // provide some defaults
    let year = PLAN_YEARS[PLAN_YEARS.length - 1];
    let type = 'ushouse';

    // Match: predict, predict0, predictD12, predictR12, or 4-digit years
    const year_and_type = /^#!(predict(?:[DR]\d+|\d+)?|\d\d\d\d)\-(\w+)$/.exec(window.location.hash);
    if (year_and_type) {
        year = year_and_type[1];
        type = year_and_type[2];
    }

    // If we have a prediction year from the URL, parse it and set the slider value
    if (isPredictionYear(year)) {
        const match = year.match(/predict([DR])?(\d+)?/);
        if (match) {
            const party = match[1];  // 'D', 'R', or undefined
            const value = match[2] ? parseInt(match[2]) : 0;
            if (party === 'R') {
                PREDICTION_SLIDER.currentValue = -value;
            } else if (party === 'D') {
                PREDICTION_SLIDER.currentValue = value;
            } else {
                PREDICTION_SLIDER.currentValue = 0;
            }
        }
    }

    // ready, set, go
    selectYear(year);
    selectBoundaryType(type);
};

window.handleResize = () => {
    // various things that don't gracefully handle being resized, so we need to help them out

    // the desktop "bead string" yearpicker; stretch the DIVs to fill the width
    const $picker_buttons = $('#yearpicker-big').find('div');
    const width = `${100 / $picker_buttons.length}%`;
    $picker_buttons.css({ width });
};


//
// RUNTIME FUNCTIONS FOR CHANGING YEAR + DISTRICT TYPE + STATE INFO
// loadDataForSelectedBoundaryAndYear() is the real worker here; the others are basically convenience functions
//

// Helper: Convert prediction slider value to year string
// value: -12 to +12 (negative = R, positive = D, 0 = Even)
// returns: "predict0", "predictD12", "predictR12", etc.
window.getPredictionYearString = (value) => {
    if (value === 0) return 'predict0';
    if (value > 0) return `predictD${value}`;
    return `predictR${Math.abs(value)}`;
};

// Helper: Check if a year string is a prediction year
// returns: true for "predict", "predict0", "predictD5", "predictR12", etc.
window.isPredictionYear = (year) => {
    return String(year).startsWith('predict');
};

// Helper: Extract base year from prediction string for CSV lookup
// returns: "predict" for all prediction variants, or the original year for others
window.getBaseYear = (year) => {
    return isPredictionYear(year) ? 'predict' : year;
};

window.loadDataForSelectedBoundaryAndYear = (options={}) => {
    if (! CURRENT_VIEW.year || ! CURRENT_VIEW.boundtype) return;  // need both; during startup one will be blank, so avoid an error

    // options documentation
    // * fudgeYearIfNoData:true -- if no data for given boundary & year, select closest year which DOES have data and use that instead
    // * noHashUpdate:true -- suppress updating the #! hash in address bar

    // initialize the bias score statistics to No Data all around
    // expected data structure: list of states and their bias ratings
    const chartdata = [];
    for (const [stateabbr, statename] of Object.entries(STATE_CODE_TO_NAME)) {
        chartdata.push({
            abbr: stateabbr,
            name: statename,
            value: MAP_NODATA_VALUE,
            percentrank: null,
        });
    }

    // fetch the CSV file and then use the callbacks to update the map
    const boundtypeFile = (CURRENT_VIEW.boundtype === 'ushouse') ? 'ushouse-elections' : CURRENT_VIEW.boundtype;
    const url = `/data/bias_${boundtypeFile}.csv`;
    Papa.parse(url, {
        download: true,
        header: true,
        complete: function (results) {
            // https://github.com/PlanScore/PlanScore/issues/169, if fudgeYearIfNoData is enabled and we have no data for this year, pick another year
            // nearest year to our chosen which does have data, favoring more-recent year in event of a tie
            // primarily used when switching district types, as not all district types have the same coverage for every year (e.g. State House 2016)
            if (options.fudgeYearIfNoData) {
                const yearColumn = CURRENT_VIEW.boundtype === 'ushouse' ? 'cycle' : 'year';
                const baseYear = getBaseYear(CURRENT_VIEW.year);
                const hasdata = results.data.filter((datarow) => { return datarow[yearColumn] == baseYear; }).length;
                if (! hasdata) {
                    const wehavetheseyears = results.data.map((datarow) => {
                        return datarow[yearColumn] ? parseInt(datarow[yearColumn]) : 0;  // workaround for 176, iOS 11 including blank rows so year=NaN
                    });
                    wehavetheseyears.sort((p, q) => {
                        const px = Math.abs(p - parseInt(CURRENT_VIEW.year));
                        const qx = Math.abs(q - parseInt(CURRENT_VIEW.year));
                        return (px != qx) ? (px > qx ? 1 : -1) : (p > q ? -1 : 1); // order by diff from desired year; or else by higher-year if equal spread
                    });
                    let closestyear = wehavetheseyears[0];

                    // special behavior, https://github.com/PlanScore/PlanScore/issues/228
                    // if they selected State Senates 2004 or 2014, snap to 2002 or 2012 instead because we have more data there
                    // this will likely need to be updated a few times as we get more data and 2004 & 2014 become acceptably populated, and/or more data-poor years are added which we want to rewrite
                    if      (CURRENT_VIEW.boundtype == 'statesenate' && closestyear == 2014) closestyear = 2012;
                    else if (CURRENT_VIEW.boundtype == 'statesenate' && closestyear == 2004) closestyear = 2002;

                    // done, go ahead and select THIS year for them
                    setTimeout(function () {
                        selectYear(closestyear);
                    }, 1);
                    return;
                }
            }

            // https://github.com/PlanScore/PlanScore/issues/217: odd-numbered years
            // our whole yearpicker concept was based on even-numbered years,
            // but a few states have unusual cycles such as odd-numbered years, and some unusual cases e.g. KY which in 1981-1984 changed from odd-numbered to even-numbered
            // workaround here: rewrite any odd-numbered years to add 1 (1973 becomes 1974) so we still have even numbers
            // for this visual display having 1974 show the plan enacted in 1973 is sufficiently accurate
            results.data = results.data.map(function (datarow) {
                // For ushouse, use 'cycle' column instead of 'year'
                const yearColumn = CURRENT_VIEW.boundtype === 'ushouse' ? 'cycle' : 'year';
                const year = parseInt(datarow[yearColumn]);
                if (year % 2 == 1) datarow[yearColumn] = String(year + 1);
                return datarow;
            });

            if (CURRENT_VIEW.boundtype === 'ushouse') {
                const seatBiases = {};
                const stateAreas = {};
                const rawScales = {};
                results.data.forEach(function (datarow) {
                    const value = parseFloat(datarow.EG);
                    const seats = parseInt(datarow.seats);

                    if (value === MAP_NODATA_VALUE || value === undefined || !seats) return;

                    // Calculate seat bias impact values: abs(bias) * seats
                    const seatBias = Math.abs(value) * seats;

                    // Look up raw state areas to normalize scales
                    const $shape = $(`#state-shape-${datarow.stateabrev}`);
                    const stateArea = parseFloat($shape.attr('data-area')) || 1;

                    // Dimensionless raw scale that we'll adjust later
                    rawScales[`${datarow.stateabrev}-${datarow.cycle}`] = Math.sqrt(seatBias * 1e11 / stateArea);
                });

                // Find the P10 and P90 raw scales to guide visual range
                const scalesList = Object.values(rawScales).sort(function (a, b) { return a - b });
                const p90RawScale = scalesList[Math.round(scalesList.length * 0.9)];
                const p10RawScale = scalesList[Math.round(scalesList.length * 0.1)];
                console.log(`p10RawScale ${p10RawScale.toFixed(2)}, p90RawScale ${p90RawScale.toFixed(2)}`);

                // Set bounds for visual scale range
                const minScaleFactor = 0.25;
                const maxScaleFactor = 1.25;

                // Choose a reasonable visual scale
                results.data.forEach(function (datarow) {
                    // Start with just a raw value
                    let stateScale = rawScales[`${datarow.stateabrev}-${datarow.cycle}`];
                    if (stateScale === undefined) return;

                    // Clamp at P10-P90
                    const clamped = (stateScale < p10RawScale) || (p90RawScale < stateScale);
                    stateScale = Math.min(Math.max(stateScale, p10RawScale), p90RawScale);

                    // Normalize [P10..P90] to [0..1]
                    stateScale = (stateScale - p10RawScale) / (p90RawScale - p10RawScale);

                    // Normalize [0..1] to [minScaleFactor..maxScaleFactor]
                    stateScale = (stateScale * (maxScaleFactor - minScaleFactor)) + minScaleFactor;

                    datarow.stateScale = stateScale;

                    // const key = `${datarow.stateabrev}-${datarow.cycle}`;
                    // console.log(`${key}: stateScale ${stateScale.toFixed(2)} from rawScales ${rawScales[key].toFixed(2)} ${clamped ? '(clamped)' : ''}`);
                });
            } else {
                // Detect if a plan is new for this state + election
                var last_plan;
                for (var datarow of results.data.sort((dr1, dr2) => dr1.code > dr2.code)) {
                    datarow.newplan = datarow.plan != last_plan ? "yes" : "no";
                    last_plan = datarow.plan;
                }
            }

            // filter by the year (geography is implicit by which CSV was fetched)
            // and for each row assign the bias score to the state's row in the above
            // this is loop-within-loop as we match arrays to arrays, but P=50 and Q=20ish so it's affordable
            const baseYear = getBaseYear(CURRENT_VIEW.year);
            results.data.forEach(function (datarow) {
                // Boolean flag for mid-cycle redistricting on this plan
                const numericYear = isPredictionYear(CURRENT_VIEW.year) ? 2026 : CURRENT_VIEW.year;
                const midCycleplan = (datarow.newplan == "yes") && (numericYear % 10 != 2);

                // For ushouse, use different column names
                if (CURRENT_VIEW.boundtype === 'ushouse') {
                    if (datarow.cycle != baseYear) return;  // wrong year; next
                    const chartrow = chartdata.filter((filteringthisonerow) => { return filteringthisonerow.abbr == datarow.stateabrev; })[0];
                    if (!chartrow) return;  // state not found, skip
                    chartrow.value = parseFloat(datarow.EG);
                    chartrow.seats = parseInt(datarow.seats);
                    chartrow.percentrank = null;
                    chartrow.url = datarow.url;
                    chartrow.districts = datarow.districts ? JSON.parse(datarow.districts) : undefined;
                    chartrow.stateScale = datarow.stateScale;
                    chartrow.midcyclePlan = midCycleplan;
                } else {
                    if (datarow.year != baseYear) return;  // wrong year; next
                    const chartrow = chartdata.filter((filteringthisonerow) => { return filteringthisonerow.abbr == datarow.state; })[0];
                    if (!chartrow) return;  // state not found, skip
                    chartrow.value = parseFloat(datarow.eg_adj_avg);
                    chartrow.percentrank = Math.round(100 * datarow.eg_avg_percentrank).toFixed(0);
                    chartrow.midcyclePlan = false; // midCycleplan; // not feeling confident we know state lege midcycle flags
                }
            });
            renderMapWithNewData(chartdata);
            updateStateListingSwatches(chartdata);
            updateStateListingHashes(chartdata);
            if (! options.noHashUpdate) updateAddressHash();
            reloadStatePopup();
        },
        error: function () {
            // an error, meaning bad network or missing CSV
            // fortunately we constructed a "blank" structure above, and can roll with that
            renderMapWithNewData(chartdata);
            updateStateListingSwatches(chartdata);
            updateStateListingHashes(chartdata);
        },
    });

    function updateTooltipContent(stateInfo) {
        const isPrediction = (CURRENT_VIEW.year == 2026 || isPredictionYear(CURRENT_VIEW.year)) && stateInfo.url;

        // Update tooltip content with state data
        $('#state-tooltip .state-name').text(stateInfo.name);

        // Format and display bias percentage with party affiliation
        if (stateInfo.value !== MAP_NODATA_VALUE && stateInfo.value !== undefined) {
            const biasPercent = twoDigits(Math.abs(stateInfo.value * 100));
            const biasSeats = twoDigits(Math.abs(stateInfo.value * stateInfo.seats));
            const party = stateInfo.value >= 0 ? 'Democratic' : 'Republican';
            const turnoutNote = isPrediction ? '<sup>†</sup>' : '';
            $('#state-tooltip .bias').html(`${biasPercent}% (${biasSeats} seats)${turnoutNote} pro-${party}`);
        } else {
            $('#state-tooltip .bias').text('No data');
        }

        // Update link with current year
        const plan_or_election = 'plan';
        const stateslug = stateInfo.name.toLowerCase().replace(/\W/g, '_');
        const currview = CURRENT_VIEW.boundtype;
        const moreinfourl = stateInfo.url ? stateInfo.url : `/${stateslug}/#!${CURRENT_VIEW.year}-${plan_or_election}-${currview}`;
        var labelPrefix = CURRENT_VIEW.year;
        if (isPredictionYear(CURRENT_VIEW.year)) {
            labelPrefix = 'Predicted';
        } else if (isPrediction) {
            labelPrefix = '2024+Remaps<sup>*</sup>';
        } else if (CURRENT_VIEW.year == 2026) {
            labelPrefix = 2024;
        }
        const linkHtml = `(${labelPrefix} Plan)`;
        $('#state-tooltip .link').attr('href', moreinfourl).html(linkHtml);

        // Show/hide link based on data and seat count
        const hasValue = stateInfo.value !== MAP_NODATA_VALUE && stateInfo.value !== undefined;
        const hasSeats = stateInfo.seats >= MINIMUM_USHOUSE_SEATS || stateInfo.seats == undefined;
        if (hasValue && (hasSeats || stateInfo.url)) {
            $('#state-tooltip .link').css('display', 'inline');
        } else {
            $('#state-tooltip .link').css('display', 'none');
        }
    }

    function renderMapWithNewData(data) {
        // attach this raw data into the SVG so we can access it later
        // see also selectState() which needs to access the compiled data
        $('#map').data('biasdata', data);

        // Calculate scales for U.S. House view
        let scaleFactors = {};
        if (CURRENT_VIEW.boundtype === 'ushouse') {
            let biasSeats = 0;
            let totalSeats = 0;
            data.forEach(function(stateData) {
                const seats = stateData.seats;
                if (stateData.value !== MAP_NODATA_VALUE && stateData.value !== undefined && seats) {
                    // Accumulate bias weighted by seats for national summary
                    biasSeats += stateData.value * seats;
                    totalSeats += seats;
                }
            });

            // Nationwide EG average
            const nationalEG = biasSeats / totalSeats;

            const biasEval = lookupBias('eg', nationalEG, CURRENT_VIEW.boundtype);
            const absBiasPercent = twoDigits(Math.abs(100 * nationalEG));
            const absBiasSeats = twoDigits(Math.abs(nationalEG * totalSeats));
            var currYear = CURRENT_VIEW.year;
            var turnoutNote = '';
            if (isPredictionYear(CURRENT_VIEW.year)) {
                currYear = '2026 Predictions';
                turnoutNote = '<sup>†</sup>';
            } else if(CURRENT_VIEW.year == 2026) {
                currYear = '2024+Remaps<sup>*</sup>';
                turnoutNote = '<sup>†</sup>';
            }
            $('#ushouse-legend .swatch').css({ 'background': biasEval.color });
            $('#ushouse-legend .caption').html(`Total ${currYear} Bias:`);
            $('#ushouse-legend .bias').html(`${absBiasPercent}% (${absBiasSeats} seats)${turnoutNote} pro-${biasEval.party}`);
        }

        // loop through each state in the data and update the SVG
        data.forEach(function(stateData) {
            const stateAbbr = stateData.abbr;
            const stateValue = stateData.value;

            // find the SVG elements for this state
            const $shape = $(`#state-shape-${stateAbbr}`);
            const $label = $(`#state-label-${stateAbbr}`);
            const $underline = $(`#state-underline-${stateAbbr}`);
            const $offshoreBox = $(`#offshore-box-${stateAbbr}`);
            const hasOffshoreBox = ($offshoreBox.length > 0);

            if ($shape.length === 0) return; // skip if state not found

            // Apply scaling for national bias or reset to normal
            const scaleFactor = stateData.stateScale || 1.0;

            // CSS transform is a matrix, we need to extract translate values
            // Matrix format: matrix(scaleX, skewY, skewX, scaleY, translateX, translateY)
            try {
                const cssTransform = window.getComputedStyle($shape[0]).transform;
                if (cssTransform && cssTransform !== 'none') {
                    const matrixMatch = cssTransform.match(MATRIX_PAT);
                    if (matrixMatch) {
                        const translateX = parseFloat(matrixMatch[2]);
                        const translateY = parseFloat(matrixMatch[3]);
                        const newTransform = `translate(${translateX}px, ${translateY}px) scale(${scaleFactor}, ${scaleFactor})`;
                        $shape.css('transform', newTransform);
                    }
                }
            } catch (e) {
                // Silently skip transform errors
            }

            // determine fill color and label color based on data
            if (stateValue === MAP_NODATA_VALUE || stateValue === undefined) {
                // no data: gray fill, gray label
                $shape.css({
                    'fill': MAP_NODATA_FILLCOLOR,
                    'stroke': '#555',
                    'stroke-width': '1.0'
                });
                $label.css('fill', MAP_NODATA_LABELCOLOR);
                $underline.css('fill', stateData.midcyclePlan ? MAP_NODATA_LABELCOLOR : MAP_TRANSPARENT);
                if (hasOffshoreBox) {
                    $offshoreBox.css({
                        'fill': MAP_NODATA_FILLCOLOR,
                        'stroke': '#555',
                        'stroke-width': '1.0'
                    });
                }
            } else {
                // has data: color based on bias score
                const biasInfo = lookupBias('eg', stateValue, CURRENT_VIEW.boundtype);
                $shape.css({
                    'fill': biasInfo.color,
                    'stroke': '#555',
                    'stroke-width': '1.0'
                });

                // Use white text for extreme values (beyond ±0.15)
                // to improve readability over dark backgrounds
                let labelColor = 'white';
                if (Math.abs(stateValue) < 0.12 || hasOffshoreBox) {
                    // Use standard label color for non-extreme values and offshore boxes
                    labelColor = MAP_LABELCOLOR;
                }
                $label.css('fill', labelColor);
                $underline.css('fill', stateData.midcyclePlan ? labelColor : MAP_TRANSPARENT);

                if (hasOffshoreBox) {
                    $offshoreBox.css({
                        'fill': biasInfo.color,
                        'fill-opacity': 0.35,
                        'stroke': '#555',
                        'stroke-width': '1.0'
                    });
                }
            }

            // add pointer cursors under the same conditions that control clicks in attachMapEventHandlers()
            if (CURRENT_VIEW.boundtype === 'ushouse') {
                // In U.S. House view, all states are clickable (show tooltip)
                $shape.css('cursor', 'pointer');
                $offshoreBox.css('cursor', 'pointer');
            } else {
                // In other views, only states with data are clickable
                if (stateValue === MAP_NODATA_VALUE || stateValue === undefined) {
                    $shape.css('cursor', 'not-allowed');
                    $offshoreBox.css('cursor', 'not-allowed');
                } else {
                    $shape.css('cursor', 'pointer');
                    $offshoreBox.css('cursor', 'pointer');
                }
            }
        });

        attachMapEventHandlers();

        // Re-enable transitions after the first render completes
        if (firstRender) {
            firstRender = false;
            // Use setTimeout to ensure the initial render is complete before re-enabling transitions
            setTimeout(function() {
                $('.state-shape').removeClass('suppress-transition');
                $('.offshore-box').removeClass('suppress-transition');
                $('.state-label').removeClass('suppress-transition');
                $('.state-underline').removeClass('suppress-transition');
            }, 100);
        }

        // Update tooltip if it's currently visible (for year changes)
        const $tooltip = $('#state-tooltip');
        const currentStateAbbr = $tooltip.data('current-state');
        if (currentStateAbbr && $tooltip.css('display') !== 'none') {
            const stateInfo = data.find(d => d.abbr === currentStateAbbr);
            if (stateInfo) {
                updateTooltipContent(stateInfo);
            }
        }
    }

    function attachMapEventHandlers()
    {
        // add click handlers if not already added
        if (!$('#map').data('handlers-attached')) {
            // click handlers for state shapes and offshore boxes
            // labels have pointer-events: none so clicks fall through
            $('.state-shape, .offshore-box').on('click', function(e) {
                const stateAbbr = $(this).attr('id').replace('state-shape-', '').replace('offshore-box-', '');
                const stateInfo = $('#map').data('biasdata').find(d => d.abbr === stateAbbr);

                if (!stateInfo) return; // state not found in data

                // compose URL for the selected state + boundary + year
                const plan_or_election = 'plan';
                const stateslug = stateInfo.name.toLowerCase().replace(/\W/g, '_');
                const currview = CURRENT_VIEW.boundtype;
                const moreinfourl = `/${stateslug}/#!${CURRENT_VIEW.year}-${plan_or_election}-${currview}`;

                // For U.S. House tab, show tooltip for ALL states
                if (CURRENT_VIEW.boundtype === 'ushouse') {
                    const $tooltip = $('#state-tooltip');

                    // log the selection
                    logToGoogleAnalytics('selectstate', stateInfo.name);

                    // Simple toggle: if already showing for this state, hide it
                    if ($tooltip.data('current-state') === stateAbbr && $tooltip.css('display') !== 'none') {
                        $tooltip.css('display', 'none');
                        $tooltip.data('current-state', null);
                    } else {
                        // Update tooltip content
                        updateTooltipContent(stateInfo);

                        // Get the state shape element and extract its anchor point (translate values)
                        const $shape = $(`#state-shape-${stateAbbr}`);
                        const styleAttr = $shape.attr('style');
                        let centerX = 0;
                        let centerY = 0;

                        // The translate values represent the anchor/center point of the shape
                        const translateMatch = styleAttr.match(/translate\(([^,]+)px,\s*([^)]+)px\)/);
                        if (translateMatch) {
                            centerX = parseFloat(translateMatch[1]);
                            centerY = parseFloat(translateMatch[2]);
                        }

                        // Position tooltip so tip (at 100, 59.5 in tooltip coordinates) points to shape center
                        // Adjust Y to keep label visible below the tip
                        const tooltipX = centerX - 130;
                        const tooltipY = centerY - 59.5 - 10;  // Extra 10px above to keep label visible


                        // Transform the entire tooltip group
                        $tooltip.attr('transform', `translate(${tooltipX}, ${tooltipY})`);

                        $tooltip.css('display', 'block');
                        $tooltip.data('current-state', stateAbbr);
                    }
                    e.stopPropagation();
                } else {
                    // For other tabs, check if state is clickable
                    if (stateInfo.value === MAP_NODATA_VALUE || stateInfo.value === undefined) {
                        return;
                    }

                    // log the selection
                    logToGoogleAnalytics('selectstate', stateInfo.name);

                    // navigate (new window if modifier key held)
                    if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                        window.open(moreinfourl);
                    } else {
                        document.location.href = moreinfourl;
                    }
                }
            });

            // hover effects - coordinate between state shapes and offshore boxes
            $('.state-shape').on('mouseenter', function() {
                const stateAbbr = $(this).attr('id').replace('state-shape-', '');
                const $offshoreBox = $(`#offshore-box-${stateAbbr}`);
                const cssTransform = window.getComputedStyle($(this)[0]).transform;
                const cssScale = parseFloat(cssTransform.match(MATRIX_PAT)[1]);

                $(this).data('hovering', true);
                $(this).css({
                    'stroke': MAP_MOUSEOVER_COLOR,
                    'stroke-width': MAP_MOUSEOVER_WIDTH / cssScale
                });
                if ($offshoreBox.length > 0) {
                    $offshoreBox.css({
                        'stroke': MAP_MOUSEOVER_COLOR,
                        'stroke-width': MAP_MOUSEOVER_WIDTH
                    });
                }
            }).on('mouseleave', function() {
                const stateAbbr = $(this).attr('id').replace('state-shape-', '');
                const $offshoreBox = $(`#offshore-box-${stateAbbr}`);

                $(this).data('hovering', false);

                // only clear if offshore box is also not being hovered
                if (!$offshoreBox.data('hovering')) {
                    $(this).css({
                        'stroke': '#555',
                        'stroke-width': '1.0'
                    });
                    if ($offshoreBox.length > 0) {
                        $offshoreBox.css({
                            'stroke': '#555',
                            'stroke-width': '1.0'
                        });
                    }
                }
            });

            $('.offshore-box').on('mouseenter', function() {
                const stateAbbr = $(this).attr('id').replace('offshore-box-', '');
                const $shape = $(`#state-shape-${stateAbbr}`);
                const cssTransform = window.getComputedStyle($shape[0]).transform;
                const cssScale = parseFloat(cssTransform.match(MATRIX_PAT)[1]);

                $(this).data('hovering', true);
                $(this).css({
                    'stroke': MAP_MOUSEOVER_COLOR,
                    'stroke-width': MAP_MOUSEOVER_WIDTH
                });
                if ($shape.length > 0) {
                    $shape.css({
                        'stroke': MAP_MOUSEOVER_COLOR,
                        'stroke-width': MAP_MOUSEOVER_WIDTH / cssScale
                    });
                }
            }).on('mouseleave', function() {
                const stateAbbr = $(this).attr('id').replace('offshore-box-', '');
                const $shape = $(`#state-shape-${stateAbbr}`);

                $(this).data('hovering', false);

                // only clear if state shape is also not being hovered
                if (!$shape.data('hovering')) {
                    $(this).css({
                        'stroke': '#555',
                        'stroke-width': '1.0'
                    });
                    if ($shape.length > 0) {
                        $shape.css({
                            'stroke': '#555',
                            'stroke-width': '1.0'
                        });
                    }
                }
            });

            $('#map').data('handlers-attached', true);
        }
    }

    function findStateInfoByName(data, state_name) {
        // find this swatch's state name, and fetch that state info from the raw data
        const state_info = data.filter((stateinfo) => { return stateinfo.name === state_name; }).slice(0, 1)[0];
        return state_info;
    }

    function updateStateListingSwatches(data) {
        const $swatches = $('.states-listing span.swatch');
        $swatches.each(function () {
            // find this swatch's state name, and fetch that state info from the raw data
            const state_name = $(this).closest('a').text().trim();
            const state_info = findStateInfoByName(data, state_name);

            // find bias color and apply CSS
            const biaseval = lookupBias('eg', state_info.value, CURRENT_VIEW.boundtype);
            const words = biaseval.description;
            const color = biaseval.color;
            if (state_info.value === MAP_NODATA_VALUE || state_info.value === undefined) {
                $(this).prop('title', words) .css({ 'background-color': MAP_NODATA_FILLCOLOR, 'border':'1px solid #95989A' });
            }
            else {
                $(this).prop('title', words).css({ 'background-color': color });
            }
        });
    }

    function updateStateListingHashes(data) {
        const $swatches = $('.states-listing a');
        $swatches.each(function () {
            const stateName = $(this).text().trim();
            const stateInfo = findStateInfoByName(data, stateName);

            const $link             = $(this);
            const baseurl = ($link.data('href') || $link.prop('href')).replace(/\#.*$/, '');
            const plan_or_election  = 'plan';
            const currview = CURRENT_VIEW.boundtype;
            const hashcomponent     = `#!${CURRENT_VIEW.year}-${plan_or_election}-${currview}`;
            const url = stateInfo.url ? stateInfo.url : `${baseurl}${hashcomponent}`;
            $link.prop('href', url);

            const hasValue = stateInfo.value !== MAP_NODATA_VALUE && stateInfo.value !== undefined;
            const hasSeats = stateInfo.seats >= MINIMUM_USHOUSE_SEATS || stateInfo.seats == undefined;
            if (hasValue && (hasSeats || stateInfo.url)) {
                $(this).removeClass('suppress-link');
            } else {
                $(this).addClass('suppress-link');
            }
        });
    }
};

window.selectYear = (year, options={}) => {
    // UI update: small/mobile yearpicker
    // if the selected year is the first/last then show/hide the prev/next buttons
    const $small_button = $('#yearpicker-small span').hide().filter(`[data-year="${year}"]`).show();
    const $prevbutton = $('#yearpicker-small div.nextprev.left');
    const $nextbutton = $('#yearpicker-small div.nextprev.right');

    if ($small_button.is(':first-child')) $prevbutton.addClass('disabled');
    else                                  $prevbutton.removeClass('disabled');
    if ($small_button.is(':last-child'))  $nextbutton.addClass('disabled');
    else                                  $nextbutton.removeClass('disabled');

    // UI update: yearpicker-big
    // remove active class from all years and add to the selected one
    const $picker_big = $('#yearpicker-big');
    $('#yearpicker-timeline a[id^="yearpicker-"], #yearpicker-future a[id^="yearpicker-"]', $picker_big).removeClass('active');
    // For prediction years, activate the "predict" element
    const yearForPicker = isPredictionYear(year) ? 'predict' : year;
    $(`#yearpicker-${yearForPicker}`, $picker_big).addClass('active');

    // save to the state BEFORE initializing slider (slider init needs this to be set)
    CURRENT_VIEW.year = year;

    // UI update: yearpicker-current indicator position and text
    // move the current year indicator to match the selected year's position
    // but hide it if year 2026 is selected (which is in the yearpicker-future SVG)
    const $current = $('#yearpicker-current', $picker_big);

    if (year == 2026 || isPredictionYear(year)) {
        // years past 2024 are in yearpicker-future, so hide the current indicator
        $current.hide();

        // initialize prediction slider when predict mode is activated
        if (isPredictionYear(year)) {
            initPredictionSlider();
        }
    } else {
        // show the indicator and position it at the selected year
        $current.show();
        const $activeYear = $(`#yearpicker-${year}`, $picker_big);
        if ($activeYear.length > 0) {
            // extract the X position from the active year's circle cx attribute
            const $circle = $activeYear.find('circle');
            const cx = $circle.attr('cx');

            if (cx) {
                // update the current year indicator elements
                $current.find('line').attr('x1', cx).attr('x2', cx);
                $current.find('text').attr('x', cx).text(year);

                // position the rect: center it at cx minus half its width (38px / 2 = 19px)
                // use calc() to handle percentage-based cx values
                $current.find('rect').attr('x', `calc(${cx} - 19px)`);
            }
        }
    }

    loadDataForSelectedBoundaryAndYear(options);  // no new options nor overrides; just pass options as-given
};

window.selectBoundaryType = (boundtype, options={}) => {
    // Hide tooltip when changing boundary types
    $('#state-tooltip').css('display', 'none').data('current-state', null);

    // UI update: highlight this button
    $('#boundarypicker div[data-boundary]').removeClass('active').filter(`[data-boundary="${boundtype}"]`).addClass('active');

    // UI update: toggle ushouse-selected class for conditional legend display
    if (boundtype === 'ushouse') {
        $('body').addClass('ushouse-selected');
    } else {
        $('body').removeClass('ushouse-selected');
    }

    // save to the state and refresh the map + data
    // per 169 this invokes a new year-fudging should we encounter a no-data condition
    CURRENT_VIEW.boundtype = boundtype;

    options = Object.assign({  // add fudgeYearIfNoData option for this special case, but do allow overrides by the caller
        fudgeYearIfNoData: true
    }, options);
    loadDataForSelectedBoundaryAndYear(options);
};

window.reloadStatePopup = () => {
    const $modal = $('#stateinfo-popup');
    const isopen = $modal.is(':visible');
    const statecode = $modal.attr('data-state');
    if (statecode && isopen) {
        selectState(statecode, { closeIfSameState: false });
    }
};

window.selectState = (stateabbr, options={}) => {
    // default options, overridden by their passed options
    options = Object.assign({
        closeIfSameState: false,  // if the popover is already showing the state being requested, then close it instead
    }, options);

    const $modal = $('#stateinfo-popup');

    // passing empty/null stateabbr is how you explicitly select no state
    if (! stateabbr) {
        $modal.attr('data-state', '').hide();
        return;
    }

    // if the popup is visible and already showing this same state, then close it
    if ( options.closeIfSameState && $modal.is(':visible') && $modal.attr('data-state') == stateabbr) {
        $modal.attr('data-state', '').hide();
        return;
    }

    // fetch the info from the map, and attach some attributes for the popup
    // tip: shallow copy via slice() so as not to mutate the existing one
    const biasinfo = $('#map').data('biasdata').filter((statedata) => { return statedata.abbr === stateabbr; }).slice(0, 1)[0];

    // add to the info, an analysis
    if (biasinfo.value === undefined || biasinfo.value === MAP_NODATA_VALUE) {
        biasinfo.analysis = 'No data was available for this election year.';
    }
    else {
        const favor_party = lookupBias('eg', biasinfo.value, CURRENT_VIEW.boundtype).party;

        if (favor_party) {
            biasinfo.analysis = `This plan is more skewed than <b>${biasinfo.percentrank}%</b> of the enacted plans we have analyzed nationwide.`;
        }
        else {
            biasinfo.analysis = "No consistent skew was found in favor of either party.";
        }
    }

    // the URL for more info: the state name, mangled for URLs e.g. south_carolina
    // and with a hash for the current year + district:   #!2010-plan-ushouse
    // see the states page programming for details as to the expected hash params
    const plan_or_election = 'plan';
    const stateslug        = biasinfo.name.toLowerCase().replace(/\W/g, '_');
    const moreinfourl      = `/${stateslug}/#!${CURRENT_VIEW.year}-${plan_or_election}-${CURRENT_VIEW.boundtype}`;

    // open the popup and do the string replacements
    $modal.attr('data-state', stateabbr);
    $modal.show();
    $modal.find('span[data-field="statename"]').html(biasinfo.name);
    $modal.find('span[data-field="analysis"]').html(biasinfo.analysis);
    if (biasinfo.value && biasinfo.value !== MAP_NODATA_VALUE) {
        $modal.find('a.learnmore').prop('href', moreinfourl).show();
    }
    else {
        $modal.find('a.learnmore').hide();
    }
};

window.yearAnimationToggle = () => {
    const $picker_big = $('#yearpicker-big');

    if (ANIMATION.timer) {
        clearInterval(ANIMATION.timer);
        ANIMATION.timer = undefined;

        // show paused state (play button)
        $('#yearpicker-playbutton a[data-status="paused"]', $picker_big).removeClass('hidden').siblings().addClass('hidden');

        updateAddressHash();  // per 135 #! update explicitly suppressed and explicitly requested on pause
    }
    else {
        ANIMATION.timer = setInterval(function () {
            const i = PLAN_YEARS.indexOf(parseInt(CURRENT_VIEW.year));
            let n = i + 1;
            if (n >= PLAN_YEARS.length) n = 0;  // loop back to if +1 would be past the end
            selectYear(PLAN_YEARS[n], { noHashUpdate: true});
        }, 1000 * ANIMATION.delayseconds);

        // show playing state (pause button)
        $('#yearpicker-playbutton a[data-status="playing"]', $picker_big).removeClass('hidden').siblings().addClass('hidden');
    }
};

window.updateAddressHash = () => {
    // see also initLoadStartingConditions() which will load such a state
    const hash = `#!${CURRENT_VIEW.year}-${CURRENT_VIEW.boundtype}`;
    window.location.replace(hash);
};

window.logToGoogleAnalytics = (eventtype, value) => {
    const actiontype = `frontpage-${eventtype}`;
    gtag('event', actiontype, {
        event_category: value,
    });
};
